
1
00:00:16,750 --> 00:00:22,656
（使用XCODE和LLDB
进行高级调试）

2
00:00:22,723 --> 00:00:25,092
（演讲412）

3
00:00:29,696 --> 00:00:33,767
大家好 欢迎来到“使用Xcode
和LLDB进行高级调试”

4
00:00:33,834 --> 00:00:35,769
我是Chris Miles
Xcode团队的工程经理之一

5
00:00:35,836 --> 00:00:38,372
今天我非常高兴能够来到这里

6
00:00:38,772 --> 00:00:41,475
我知道你们已经对稍后的啤酒狂欢节
早已迫不及待

7
00:00:41,542 --> 00:00:43,443
所以谢谢你们的光临

8
00:00:43,577 --> 00:00:44,645
我们会及时结束

9
00:00:44,811 --> 00:00:47,147
但今天我们为你提供了
许多精彩的内容

10
00:00:47,548 --> 00:00:48,782
所以我们马上来看看吧

11
00:00:49,583 --> 00:00:52,786
我想先谈谈Swift调试的可靠性

12
00:00:53,220 --> 00:00:55,722
这里的重点是我们带来了好消息

13
00:00:55,923 --> 00:00:59,960
我们团队已在Xcode 10中
修复了很多可靠性问题

14
00:01:02,095 --> 00:01:03,931
谢谢

15
00:01:08,502 --> 00:01:10,971
编译器和调试器团队已经解决了

16
00:01:11,038 --> 00:01:14,441
许多导致Swift调试
令人头痛的问题

17
00:01:14,675 --> 00:01:16,243
我想告诉你们其中几个

18
00:01:17,477 --> 00:01:20,013
在某些情况下
通常是在更复杂的项目或构建配置中

19
00:01:20,080 --> 00:01:22,749
尝试po一个对象

20
00:01:22,816 --> 00:01:25,085
或在控制台中执行一条表达式

21
00:01:25,786 --> 00:01:27,855
可能会失败
并产生这样的错误信息

22
00:01:28,589 --> 00:01:32,626
此错误所说的AST上下文
是一个表达式上下文

23
00:01:32,693 --> 00:01:35,829
LLDB需要它来恢复你构建项目时

24
00:01:35,896 --> 00:01:37,231
编译器的状态

25
00:01:37,598 --> 00:01:38,565
而在某些情况下

26
00:01:38,632 --> 00:01:40,100
比如当模块有冲突时

27
00:01:40,400 --> 00:01:43,570
这时表达式上下文不能可靠地重建

28
00:01:43,837 --> 00:01:45,305
你的表达式就会失败

29
00:01:46,273 --> 00:01:49,343
在Xcode 10中
LLDB实现了回退机制

30
00:01:49,409 --> 00:01:51,011
以处理这种情况

31
00:01:51,278 --> 00:01:53,213
如果它不能重建上下文

32
00:01:53,547 --> 00:01:56,083
它会回退到创建一个
当前帧的更简单的上下文

33
00:01:56,316 --> 00:01:59,319
并使用它来评估你的表达式

34
00:02:00,854 --> 00:02:03,090
一些开发者可能遇到的另一种错误

35
00:02:03,357 --> 00:02:06,894
是由于调试器无法在调试时
实现某些变量类型

36
00:02:07,127 --> 00:02:07,995
所造成的

37
00:02:08,695 --> 00:02:11,565
这在Xcode中看起来像这样

38
00:02:11,932 --> 00:02:13,967
在左侧 你可以看到变量视图

39
00:02:14,034 --> 00:02:15,936
显示了当前帧中所有变量的名称

40
00:02:16,336 --> 00:02:18,605
但不会显示任何类型信息或值

41
00:02:18,972 --> 00:02:21,308
尝试打印出变量的值

42
00:02:21,508 --> 00:02:23,076
可能会失败并产生像这样的错误

43
00:02:24,711 --> 00:02:26,914
现在 再次感谢你们的漏洞报告

44
00:02:26,980 --> 00:02:30,417
我们团队已经能够追踪并修复这些

45
00:02:30,484 --> 00:02:33,320
调试信息不能可靠生成的边缘案例

46
00:02:33,754 --> 00:02:36,089
所以我想再次代表团队感谢你们

47
00:02:36,156 --> 00:02:39,259
在遇到调试问题时

48
00:02:39,326 --> 00:02:40,594
能够提交问题报告

49
00:02:40,928 --> 00:02:43,931
如果你在调试项目时
发现Xcode 10

50
00:02:43,997 --> 00:02:45,098
还有其他问题

51
00:02:45,399 --> 00:02:47,234
请继续为我们提交错误报告

52
00:02:47,634 --> 00:02:49,136
对于参加这次演讲的你们来说

53
00:02:49,203 --> 00:02:50,437
如果你发现项目存在问题

54
00:02:50,504 --> 00:02:51,705
请到实验室来

55
00:02:51,772 --> 00:02:55,676
明天早上我们有一个
Xcode调试和分析实验

56
00:02:55,742 --> 00:02:56,677
从九点到十二点

57
00:02:57,077 --> 00:02:59,246
带上你的项目并找到
Xcode调试工程师

58
00:02:59,446 --> 00:03:02,282
或LLDB工程师
他们很期待看到你的项目

59
00:02:59,446 --> 00:03:02,282
或LLDB工程师
他们很期待看到你的项目

60
00:03:05,419 --> 00:03:07,321
现在我想继续告诉你

61
00:03:07,387 --> 00:03:10,157
一些我最喜欢的调试技巧和窍门

62
00:03:10,424 --> 00:03:12,826
我喜欢用它们来增强我的调试流程

63
00:03:13,393 --> 00:03:15,028
事实上 我不只是要告诉你

64
00:03:15,162 --> 00:03:16,697
我还想为你演示一下

65
00:03:26,306 --> 00:03:29,743
我们今天要使用的项目是一个叫做
Solar System的iOS app

66
00:03:29,977 --> 00:03:32,980
你可能见到过
Solar System出现在

67
00:03:33,046 --> 00:03:35,182
Keynote演讲
和“国情咨文”中

68
00:03:35,849 --> 00:03:38,218
我们将要调试
Solar System中的一个部分

69
00:03:38,352 --> 00:03:39,419
其被称为Moon Jumper

70
00:03:40,354 --> 00:03:42,523
Moon Jumper
允许用户握住手机

71
00:03:42,589 --> 00:03:43,724
并跳到空中

72
00:03:44,525 --> 00:03:45,993
该app可衡量你的跳跃力量

73
00:03:46,059 --> 00:03:48,128
然后将其转换为月球重力

74
00:03:48,529 --> 00:03:51,298
并向你展示如果你站在月球上

75
00:03:51,365 --> 00:03:52,733
你刚才跳跃的高度

76
00:03:53,400 --> 00:03:55,569
你可以设置一条栏来作为目标

77
00:03:55,836 --> 00:03:58,739
然后你可以试着挑战自己
尽量在月球重力下

78
00:03:58,805 --> 00:03:59,940
跳到该栏的高度

79
00:04:01,008 --> 00:04:03,610
现在我们对Moon Jumper
进行一些改进

80
00:04:04,344 --> 00:04:07,681
如一些视觉增强
和GamePlay模式

81
00:04:08,148 --> 00:04:09,383
我们还没有准备好交付

82
00:04:09,550 --> 00:04:12,519
我们已经做了一次测试
并得到一个漏洞列表

83
00:04:12,886 --> 00:04:14,154
我们需要仔细看看它

84
00:04:14,688 --> 00:04:16,223
所以这些都是
Solar System的漏洞

85
00:04:16,456 --> 00:04:18,291
我会先解决iOS上的漏洞

86
00:04:18,358 --> 00:04:22,129
稍后 Sebastian将上台
解决macOS端的漏洞

87
00:04:22,663 --> 00:04:25,632
现在 正如它所说的
谁都不能离开去参加啤酒狂欢

88
00:04:25,699 --> 00:04:27,201
直到我们修复所有这些漏洞

89
00:04:27,501 --> 00:04:31,205
所以没什么比与2000人结对编程
更令人振奋的事了

90
00:04:33,006 --> 00:04:35,642
让我们马上动手
并从第一个漏洞开始

91
00:04:35,709 --> 00:04:38,212
跳跃失败动画与规范不符

92
00:04:38,946 --> 00:04:40,047
那是在说什么？

93
00:04:40,681 --> 00:04:42,049
我们切换到模拟器

94
00:04:42,115 --> 00:04:45,519
因为我们正在使用模拟器
来加快调试和开发

95
00:04:45,819 --> 00:04:47,521
我连接了点击动作来识别它们

96
00:04:47,888 --> 00:04:49,122
所以每次我点击宇航员

97
00:04:49,189 --> 00:04:51,425
他都会成功跳到栏的高度

98
00:04:52,359 --> 00:04:54,862
现在这个漏洞说的是
当宇航员没有达到

99
00:04:54,928 --> 00:04:57,297
栏的高度的情况
所以让我们重现一下

100
00:04:57,764 --> 00:04:59,032
切换到编辑器

101
00:04:59,333 --> 00:05:02,236
我将使用跳转栏导航到jump函数

102
00:04:59,333 --> 00:05:02,236
我将使用跳转栏导航到jump函数

103
00:05:02,936 --> 00:05:04,905
并在该函数的开始处设置一个断点

104
00:05:05,472 --> 00:05:06,473
现在我点击宇航员

105
00:05:06,974 —> 00:05:09,610
我们将进行一次跳跃
现在我们在调试器中暂停了

106
00:05:10,444 --> 00:05:13,146
要指出的第一件事是在标签栏中

107
00:05:13,480 --> 00:05:14,748
这里有四个选项卡

108
00:05:14,815 --> 00:05:17,150
这个调试选项卡是由Xcode
刚为我们创建的

109
00:05:17,518 --> 00:05:19,987
对于那些像我一样
喜欢在选项卡中工作的人来说

110
00:05:20,454 --> 00:05:22,489
这是你可以定义的Xcode行为

111
00:05:26,727 --> 00:05:29,963
为了做到这一点 你需要使用
Xcode菜单来编辑行为

112
00:05:30,030 --> 00:05:33,033
这将你带到Behavior
选项卡中的首选项

113
00:05:33,100 --> 00:05:35,235
在这里你可以配置许多行为

114
00:05:35,602 --> 00:05:38,939
在这个例子中
你需要配置Running部分中的

115
00:05:39,239 --> 00:05:40,374
Pauses的行为

116
00:05:40,674 --> 00:05:44,545
这就是
当Xcode在调试器中暂停时

117
00:05:44,611 --> 00:05:45,612
所触发的行为

118
00:05:45,679 --> 00:05:48,348
你可在此看到我已配置它
显示名为Debug的选项卡

119
00:05:48,615 --> 00:05:50,551
当在调试器中暂停时
Xcode将始终

120
00:05:50,717 --> 00:05:51,852
切换到该选项卡

121
00:05:52,152 --> 00:05:54,855
对于像我一样喜欢在选项卡中
工作的用户 这非常棒

122
00:05:55,622 --> 00:05:56,590
现在切换回代码

123
00:05:56,657 --> 00:05:58,792
我们可以看到有一个条件语句
基于这个

124
00:05:59,059 --> 00:06:00,227
didReachSelectedHeight属性

125
00:05:59,059 --> 00:06:00,227
didReachSelectedHeight属性

126
00:06:00,627 --> 00:06:03,297
所以我想看看这个属性的值

127
00:06:03,597 --> 00:06:05,365
我们切换到调试控制台

128
00:06:05,732 --> 00:06:08,569
我可以使用po命令来查看
该属性的值

129
00:06:08,635 --> 00:06:09,937
它当前的值为true

130
00:06:11,004 --> 00:06:11,972
现在我想…

131
00:06:12,039 --> 00:06:14,508
点击动作只是识别我已连接
并且总是

132
00:06:14,575 --> 00:06:15,709
将其值设置为true

133
00:06:15,776 --> 00:06:18,078
我想将其更改为false
以便重现该错误

134
00:06:18,579 --> 00:06:20,681
现在我们在代码中对其进行修改

135
00:06:20,881 --> 00:06:22,883
点击以识别它
并将其设置为false

136
00:06:22,950 --> 00:06:26,587
但我不想仅为了调试目的
而对我的代码进行更改

137
00:06:26,653 --> 00:06:27,654
如果我能避免的话

138
00:06:28,021 --> 00:06:31,358
所以在这种情况下
我可以让调试器为我做这件事

139
00:06:31,425 --> 00:06:33,093
我可使用
expression命令

140
00:06:33,360 --> 00:06:37,464
我可以给它任何Swift表达式
例如

141
00:06:37,531 --> 00:06:39,733
didReachSelectedHeight=false

142
00:06:39,800 --> 00:06:42,302
它会评估并执行它

143
00:06:42,436 --> 00:06:45,873
现在我们可以看到这个属性
确实已经变成了false

144
00:06:46,473 --> 00:06:48,642
如果我使用调试器单步执行这行代码

145
00:06:48,709 --> 00:06:51,044
可以看到 我们已进入了
分支的else语句块

146
00:06:51,645 --> 00:06:53,780
当我们继续运行时
我们可以看到宇航员

147
00:06:54,181 --> 00:06:56,717
无法跳到栏的高度并掉落下来

148
00:06:57,217 --> 00:06:59,086
这正是我们试图重现的情况

149
00:06:59,152 --> 00:07:02,389
我希望每次点击宇航员时
都会发生这种情况

150
00:06:59,152 --> 00:07:02,389
我希望每次点击宇航员时
都会发生这种情况

151
00:07:02,556 --> 00:07:05,058
但我不想每次都暂停
并输入这个表达式

152
00:07:05,626 --> 00:07:08,562
所以我要做的就是配置这个断点
来为我做这件事

153
00:07:09,296 --> 00:07:10,631
如果我右键点击断点

154
00:07:10,998 --> 00:07:12,566
我可以选择
Edit Breakpoint

155
00:07:13,000 --> 00:07:14,568
这将显示一个弹出窗口

156
00:07:15,035 --> 00:07:18,472
用一些配置来定制断点的行为

157
00:07:18,839 --> 00:07:20,908
我将Action设置为
Debugger Command

158
00:07:21,708 --> 00:07:23,744
并输入表达式命令

159
00:07:23,810 --> 00:07:26,680
即我在调试控制台中使用的命令

160
00:07:27,948 --> 00:07:29,950
并使其成为一个自动继续断点

161
00:07:30,417 --> 00:07:31,985
我们在这里配置的是一个断点

162
00:07:32,052 --> 00:07:34,021
一旦执行到这个函数

163
00:07:34,087 --> 00:07:35,389
该断点将被触发

164
00:07:35,455 --> 00:07:36,757
为我们执行这个命令

165
00:07:36,857 --> 00:07:39,359
更改属性的值
然后自动继续执行

166
00:07:39,760 --> 00:07:41,428
现在每当我点击宇航员时

167
00:07:41,728 --> 00:07:44,531
他都会执行这个不成功的跳跃并回落

168
00:07:45,132 --> 00:07:47,067
现在我们需要解决什么问题呢？

169
00:07:47,534 --> 00:07:49,269
规范说 跌倒后

170
00:07:49,336 --> 00:07:51,071
宇航员应该再次站起来

171
00:07:51,438 --> 00:07:52,639
现在我们来修复它

172
00:07:53,607 --> 00:07:57,277
我将导航到此函数
updateUIForJumpFailed

173
00:07:57,744 --> 00:08:00,080
我们可以看到这个函数
使用UIKit Dynamics

174
00:07:57,744 --> 00:08:00,080
我们可以看到这个函数
使用UIKit Dynamics

175
00:08:00,147 --> 00:08:02,382
来模拟失败跳跃

176
00:08:02,916 --> 00:08:05,853
它首先创建一个
UIDynamicAnimator

177
00:08:06,153 --> 00:08:09,022
然后调用一个函数来添加行为
以创建物理效果

178
00:08:09,423 --> 00:08:12,693
然后宇航员应该在
dynamicAnimatorDidPause代理回调中

179
00:08:12,960 --> 00:08:16,463
被重新调整方向并定位到屏幕中间

180
00:08:17,331 --> 00:08:19,566
现在我们可以向下滚动
并看到委托回调

181
00:08:19,766 --> 00:08:21,235
已成功实现

182
00:08:21,502 --> 00:08:22,402
这部分看起来很好

183
00:08:22,936 --> 00:08:25,572
但我注意到这个对象没有设置委托

184
00:08:26,340 --> 00:08:28,408
所以如果我在这里添加该代码

185
00:08:28,775 --> 00:08:30,911
我认为这个更改可以解决我们的问题

186
00:08:31,512 --> 00:08:34,114
现在我可以重新编译并运行

187
00:08:34,313 --> 00:08:35,682
并尝试和验证我的修复

188
00:08:36,049 --> 00:08:38,485
但如果可以的话
我想尽量缩短整个周期

189
00:08:38,552 --> 00:08:42,256
所以我要做的是使用一个断点
来为我注入这个变化

190
00:08:42,322 --> 00:08:46,026
以便我可以快速方便地看到
这是否可以解决问题

191
00:08:46,660 --> 00:08:50,430
我在这里创建一个断点
双击打开编辑窗口

192
00:08:51,031 --> 00:08:53,033
这是调出编辑窗口的快捷方式

193
00:08:53,433 --> 00:08:55,602
然后再次使用值为
Debugger Command的Action

194
00:08:55,669 --> 00:08:56,870
来注入一个表达式

195
00:08:57,137 --> 00:08:59,373
输入我认为能解决问题的

196
00:08:59,473 --> 00:09:00,741
那行代码

197
00:08:59,473 --> 00:09:00,741
那行代码

198
00:09:01,241 --> 00:09:02,976
并使其成为一个自动继续的断点

199
00:09:03,410 --> 00:09:04,311
我在这里进行配置

200
00:09:04,378 --> 00:09:05,679
尽管我已经修改了代码

201
00:09:05,746 --> 00:09:06,980
但我还没有重新编译过

202
00:09:07,147 --> 00:09:09,416
我通过使用自定义断点

203
00:09:09,483 --> 00:09:10,817
来为我注入更改

204
00:09:10,884 --> 00:09:13,820
因此我可以使用
当前的实时app进行测试

205
00:09:14,388 --> 00:09:15,522
如果我现在点击宇航员

206
00:09:15,589 --> 00:09:19,059
他执行了这次不成功的跳跃并摔倒
然后重新站起来

207
00:09:19,126 --> 00:09:20,694
我们似乎已经解决了这个问题

208
00:09:20,928 --> 00:09:22,596
我喜欢这个效果
我打算再做一次

209
00:09:28,602 --> 00:09:31,004
现在我们再看看笔记

210
00:09:31,939 --> 00:09:34,007
我们可以勾掉第一个

211
00:09:34,842 --> 00:09:35,976
漏洞表示已修复

212
00:09:36,610 --> 00:09:38,779
没有比勾掉已修复的漏洞更好的事了

213
00:09:39,446 --> 00:09:42,249
接下来的三个漏洞
是关于新的GamePlay模式的

214
00:09:42,316 --> 00:09:43,183
我一直在研究它

215
00:09:43,317 --> 00:09:45,652
我在模拟器中
点击Play向你展示它

216
00:09:45,853 --> 00:09:49,156
这里的挑战是
尝试跳过栏10次以上

217
00:09:49,456 --> 00:09:51,658
栏一开始较低
随后每次升高一些

218
00:09:53,193 --> 00:09:56,096
你还可以看到
顶部添加了一些分数标签

219
00:09:56,430 --> 00:09:57,598
如果我点击宇航员

220
00:09:57,831 --> 00:10:00,367
你会看到他仍然被配置为
执行不成功的跳跃

221
00:09:57,831 --> 00:10:00,367
你会看到他仍然被配置为
执行不成功的跳跃

222
00:10:00,868 --> 00:10:03,537
这时顶部的Attempts标签
应该增加

223
00:10:03,804 --> 00:10:04,638
但它没有

224
00:10:04,972 --> 00:10:06,406
这是我们在此遇到的
第一个漏洞

225
00:10:06,473 --> 00:10:08,141
这个标签闪了一下但没有改变

226
00:10:08,876 --> 00:10:10,978
我们也遇到了游戏结束状态

227
00:10:11,044 --> 00:10:12,179
处理不当的问题

228
00:10:12,579 --> 00:10:15,282
及Scores标签
和Attempts标签布局问题

229
00:10:15,349 --> 00:10:16,517
我们稍后再解决它们

230
00:10:16,950 --> 00:10:17,951
回到这个漏洞

231
00:10:18,418 --> 00:10:20,387
如果你没有注意到
让我再次点击宇航员

232
00:10:20,454 --> 00:10:22,489
并密切关注顶部的
Attempts标签

233
00:10:23,190 --> 00:10:25,692
你会看到它闪了一下但没有更新

234
00:10:26,126 --> 00:10:29,029
所以这表明标签正在获取一个值

235
00:10:29,096 --> 00:10:30,797
因为我们看到了过渡动画

236
00:10:31,331 --> 00:10:32,499
然而值不正确

237
00:10:32,666 --> 00:10:34,101
所以我想找到

238
00:10:34,368 --> 00:10:36,136
修改此标签的代码

239
00:10:36,336 --> 00:10:38,071
来看看它的逻辑是什么

240
00:10:38,705 --> 00:10:41,542
我们注意到用户界面标签正在尝试
改变文本属性

241
00:10:41,775 --> 00:10:44,077
所以我要做的是切换到断点导航器

242
00:10:44,511 --> 00:10:46,680
并点击底部这里的加号按钮

243
00:10:46,980 --> 00:10:49,383
来创建这些专门断点之一

244
00:10:50,050 --> 00:10:52,052
你可以看到这里有
Swift Error Breakpoint

245
00:10:52,119 --> 00:10:53,787
和Exception Breakpoint
甚至Test Failure Breakpoint

246
00:10:54,054 --> 00:10:56,190
但在这个例子中
我将使用Symbolic Breakpoint

247
00:10:57,124 --> 00:10:59,326
这样就创建了一个新的断点
并启动了编辑器

248
00:10:59,393 --> 00:11:02,963
在这里我们可以输入任何函数

249
00:10:59,393 --> 00:11:02,963
在这里我们可以输入任何函数

250
00:11:03,030 --> 00:11:05,365
或方法名称
如我们在这里用到的

251
00:11:06,333 --> 00:11:07,701
UILabel setText

252
00:11:08,302 --> 00:11:10,404
且我们用Objective-C格式输入

253
00:11:10,470 --> 00:11:12,806
因为UIKit是一个
Objective-C框架

254
00:11:13,507 --> 00:11:17,277
需要指出的是断点下面

255
00:11:17,344 --> 00:11:19,213
有一个子行

256
00:11:19,346 --> 00:11:21,815
这是来自调试器的反馈
它告诉我们

257
00:11:21,882 --> 00:11:23,617
它能够在UIKit Core中的
一个位置

258
00:11:23,750 --> 00:11:25,552
解析这个断点

259
00:11:26,086 --> 00:11:28,121
某些符号可能会解析到多个位置

260
00:11:28,188 --> 00:11:29,489
它们都会显示在这里

261
00:11:29,556 --> 00:11:31,258
如果你没有看到子条目

262
00:11:31,425 --> 00:11:34,761
这表明调试器无法解析你的断点

263
00:11:34,862 --> 00:11:36,129
因此它永远不会命中

264
00:11:36,196 --> 00:11:37,431
准备好这些以后

265
00:11:37,764 --> 00:11:39,666
我再次点击宇航员

266
00:11:40,367 --> 00:11:43,570
现在可以看到 我们在
UILabel setText中命中了该断点

267
00:11:43,804 --> 00:11:46,607
然而我们没有UIKit的源代码

268
00:11:46,773 --> 00:11:48,208
所以我们看到的是汇编代码

269
00:11:48,509 --> 00:11:50,010
但没有必要留在黑暗中

270
00:11:50,077 --> 00:11:52,513
即使你处于一个框架的汇编代码中

271
00:11:52,880 --> 00:11:54,281
并且是系统中的的一个框架

272
00:11:54,348 --> 00:11:57,150
我们可以检查传入函数的参数

273
00:11:57,684 --> 00:11:59,987
你只需要知道该架构的调用约定

274
00:12:00,053 --> 00:12:02,456
就可以检查寄存器以查看参数

275
00:12:02,856 --> 00:12:05,259
我承认我永远记不住

276
00:12:05,859 --> 00:12:06,994
那些寄存器是什么

277
00:12:07,060 --> 00:12:09,796
但幸运的是我不必这样做
因为调试器提供了

278
00:12:09,863 --> 00:12:10,998
伪寄存器

279
00:12:11,698 --> 00:12:14,234
现在 $arg1代表保存了

280
00:12:14,301 --> 00:12:15,602
第一个参数的寄存器

281
00:12:15,836 --> 00:12:17,804
现在我们可以看看

282
00:12:17,871 --> 00:12:19,306
该Objective-C
消息的接受者

283
00:12:19,573 --> 00:12:21,041
这是一个UILabel实例

284
00:12:22,009 --> 00:12:24,278
我们看到它的值为“17 ft”

285
00:12:24,678 --> 00:12:27,381
这表明它是这里的这个高度标签

286
00:12:27,981 --> 00:12:29,516
因此它不是我们感兴趣的标签

287
00:12:29,583 --> 00:12:31,451
我们再来看看其他的参数

288
00:12:32,119 --> 00:12:34,121
如果你熟悉
objc_msgSend

289
00:12:34,388 --> 00:12:36,857
你可能会记得第二个参数
应该是选择器

290
00:12:37,558 --> 00:12:39,059
可我们并没有看到它
那是因为

291
00:12:39,126 --> 00:12:42,095
LLDB不会自动知道
这些参数的类型

292
00:12:42,162 --> 00:12:43,931
因此在某些情况下
我们需要对它进行类型转换

293
00:12:44,164 --> 00:12:45,933
现在我们看到了这个消息的选择器

294
00:12:46,633 --> 00:12:49,303
第三个参数是传递到方法中的

295
00:12:49,369 --> 00:12:50,871
第一个参数

296
00:12:51,471 --> 00:12:53,807
换句话说
它是传递给setText的字符串

297
00:12:54,174 --> 00:12:56,577
所以这对于在一个框架的汇编帧中

298
00:12:56,643 --> 00:13:00,147
检查参数来说非常方便

299
00:12:56,643 --> 00:13:00,147
检查参数来说非常方便

300
00:13:01,048 --> 00:13:02,382
这也不是我们感兴趣的标签

301
00:13:02,449 --> 00:13:05,085
所以让我们点击继续

302
00:13:05,219 --> 00:13:06,420
现在我们再次命中断点

303
00:13:06,486 --> 00:13:08,722
我们可以检查$arg1

304
00:13:08,789 --> 00:13:10,591
看看接收者是什么

305
00:13:10,891 --> 00:13:13,861
看起来它是同一个高度标签
其值现在为“0 ft”

306
00:13:14,328 --> 00:13:15,996
现在我知道我的策略出了什么问题

307
00:13:16,997 --> 00:13:18,298
当宇航员跳跃时

308
00:13:18,665 --> 00:13:20,934
代码实时更新高度标签

309
00:13:21,235 --> 00:13:26,173
所以断点会频繁地命中这个对象

310
00:13:26,406 --> 00:13:27,574
这将花费我们很长时间

311
00:13:27,641 --> 00:13:29,476
要命中一个Attempts标签的

312
00:13:29,543 --> 00:13:31,979
UILabel setText
断点是非常困难的

313
00:13:32,346 --> 00:13:36,250
所以我认为我应该做的
只是将这个符号断点

314
00:13:36,383 --> 00:13:38,252
设置在跳跃动画完成后

315
00:13:38,852 --> 00:13:40,254
有一个方法可以做到这一点

316
00:13:41,054 --> 00:13:42,923
我将切换到断点导航器

317
00:13:43,056 --> 00:13:45,859
如果我双击符号断点的指示符

318
00:13:46,126 --> 00:13:47,761
就可以重新调出编辑器

319
00:13:48,128 --> 00:13:49,696
我们可以使用这个
Condition字段

320
00:13:49,963 --> 00:13:52,332
我们可以在这里输入一个
返回true或false的表达式

321
00:13:52,699 --> 00:13:55,769
只有当该表达式计算结果
为true时 才会触发断点

322
00:13:56,170 --> 00:13:59,206
因此如果我们有一个属性
如jumpAnimationInProgress

323
00:13:59,506 --> 00:14:01,708
我们写一个表达式
测试它是否为false

324
00:13:59,506 --> 00:14:01,708
我们写一个表达式
测试它是否为false

325
00:14:01,975 --> 00:14:03,343
然后断点就会被触发

326
00:14:03,744 --> 00:14:05,045
然而我没有该属性

327
00:14:05,112 --> 00:14:06,547
我要告诉你一个不同的方法

328
00:14:07,114 --> 00:14:08,949
我将删除该符号断点

329
00:14:09,449 --> 00:14:12,819
并向下滚动到此函数
jumpCompleted

330
00:14:12,886 --> 00:14:14,087
并在这里设置一个断点

331
00:14:14,655 --> 00:14:17,791
jumpCompleted函数
将会在动画完成后被调用

332
00:14:18,225 --> 00:14:20,394
以便它可以更新用户界面
并更新游戏状态

333
00:14:21,094 --> 00:14:23,030
然而我们不希望在这个函数中中断

334
00:14:23,297 --> 00:14:26,300
我想要做的只是配置这个断点

335
00:14:26,366 --> 00:14:29,136
并让它在UILabel setText处
替我设置一个符号断点

336
00:14:29,603 --> 00:14:31,805
我可以通过添加一个
Debugger Command的Action来做到这点

337
00:14:32,472 --> 00:14:36,410
命令为breakpoint set
参数为--one-shot true

338
00:14:37,077 --> 00:14:39,680
这个一次性断点是一个临时断点

339
00:14:39,746 --> 00:14:43,150
它一旦触发后就会被自动删除

340
00:14:44,017 --> 00:14:46,019
我们给它起一个有意义的名字

341
00:14:46,887 --> 00:14:48,088
UILabel setText

342
00:14:48,255 --> 00:14:50,057
并使其成为自动继续断点

343
00:14:50,390 --> 00:14:51,959
这里我们创建了这样一个断点

344
00:14:52,359 --> 00:14:56,396
即当执行进入
jumpCompleted函数时

345
00:14:56,697 --> 00:14:58,866
它会替我们在我们感兴趣的位置

346
00:14:58,932 --> 00:15:01,134
设置一个临时断点
然后继续执行

347
00:14:58,932 --> 00:15:01,134
设置一个临时断点
然后继续执行

348
00:15:01,535 --> 00:15:03,637
从而使我们只会在进入这个函数之后

349
00:15:03,704 --> 00:15:05,506
才命中setText断点

350
00:15:06,173 --> 00:15:08,609
让我们点击继续
我们看到跳跃动画

351
00:15:08,675 --> 00:15:09,943
在模拟器中完成

352
00:15:10,911 --> 00:15:13,447
并且现在我们在UILabel setText处
触发了断点

353
00:15:14,014 --> 00:15:16,750
现在我们可以
通过使用po $arg1命令

354
00:15:17,084 --> 00:15:18,952
看看该消息的接收者

355
00:15:19,319 --> 00:15:21,955
我们看到这确实是
一个不同的UILabel实例

356
00:15:22,289 --> 00:15:23,223
其值为0

357
00:15:23,457 --> 00:15:25,425
因此它很可能是
顶部标签其中的一个

358
00:15:25,959 --> 00:15:27,561
看起来我们找到了正确的对象

359
00:15:27,628 --> 00:15:30,564
我们来看看修改这个标签值的代码

360
00:15:31,098 --> 00:15:33,000
我们可以在调试导航器中执行此操作

361
00:15:33,066 --> 00:15:34,935
通过选择栈中的下一帧

362
00:15:35,302 --> 00:15:37,638
现在我们已经找到了
修改标签值的代码

363
00:15:38,105 --> 00:15:40,707
它当前使用labelText变量

364
00:15:40,974 --> 00:15:42,442
传入一个“0”字符串

365
00:15:42,743 --> 00:15:45,379
往上看 我们看到
labelText始终被设置为

366
00:15:45,445 --> 00:15:47,781
标签的当前值
难怪它不会改变

367
00:15:48,282 --> 00:15:51,418
看起来valueText才是
包含新值的变量

368
00:15:51,485 --> 00:15:53,587
所以可能只是打错了

369
00:15:53,654 --> 00:15:54,555
让我们解决它

370
00:15:55,622 --> 00:15:57,024
我们将它改为valueText

371
00:16:00,194 --> 00:16:01,695
接下来我想做的

372
00:16:02,329 --> 00:16:04,865
不是重新编译并运行以测试此更改

373
00:16:04,932 --> 00:16:08,001
我想像之前一样
在当前运行的app上下文中

374
00:16:08,068 --> 00:16:10,571
直接测试这个改变

375
00:16:10,938 --> 00:16:13,040
所以我要在当前行的下面
添加一个断点

376
00:16:13,106 --> 00:16:15,776
请记住 我们已经更改了代码
但我们没有重新编译

377
00:16:15,843 --> 00:16:17,411
所以标签仍会被设为原来的样子

378
00:16:17,778 --> 00:16:21,081
我们在下面添加我们的代码
将其设置为我们认为正确的值

379
00:16:21,448 --> 00:16:24,985
设置另一个自定义断点
我们可以再次使用表达式

380
00:16:25,052 --> 00:16:28,355
来注入该代码并使其自动继续

381
00:16:29,590 --> 00:16:31,959
现在如果我点击继续

382
00:16:32,359 --> 00:16:33,660
代码执行将经过这里

383
00:16:33,894 --> 00:16:36,196
我们看到Attempts标签
确实已更新

384
00:16:36,964 --> 00:16:38,532
我想确保它…

385
00:16:38,732 --> 00:16:39,733
谢谢大家

386
00:16:44,671 --> 00:16:47,007
我想确保它在一次成功跳跃后

387
00:16:47,274 --> 00:16:48,542
也适用于Score标签

388
00:16:48,809 --> 00:16:51,311
让我们回到这里

389
00:16:51,745 --> 00:16:54,081
先移除jumpCompleted中的
替我们创建

390
00:16:54,147 --> 00:16:55,716
一次性断点的这个断点

391
00:16:55,782 --> 00:16:57,017
因为我们不再需要它了

392
00:16:57,384 --> 00:16:59,286
我还要禁用jump函数中的断点

393
00:16:59,353 --> 00:17:02,356
因为我们不想再改变
didReachSelectedHeight了

394
00:16:59,353 --> 00:17:02,356
因为我们不想再改变
didReachSelectedHeight了

395
00:17:02,656 --> 00:17:03,924
现在当我点击宇航员时

396
00:17:03,991 --> 00:17:05,392
他进行一次成功的跳跃

397
00:17:05,692 --> 00:17:07,794
我们可以看到所有标签都正确更新

398
00:17:07,861 --> 00:17:09,195
这样看起来很棒

399
00:17:11,231 --> 00:17:13,066
让我们回头把它勾掉

400
00:17:14,101 --> 00:17:15,636
好的 接下来的漏洞是一个

401
00:17:15,702 --> 00:17:17,271
关于游戏结束状态的问题

402
00:17:18,704 --> 00:17:20,607
游戏本应该在10次尝试后结束

403
00:17:20,674 --> 00:17:23,676
我可以点击宇航员并等待动画播放

404
00:17:23,877 --> 00:17:27,114
持续这个过程直到那个状态
以尝试重现它

405
00:17:27,548 --> 00:17:28,916
但播放动画需要一些时间

406
00:17:29,049 --> 00:17:30,918
当测试并验证我的修复程序时

407
00:17:30,984 --> 00:17:33,153
我可能需要多次这样做

408
00:17:33,487 --> 00:17:36,123
因此我想跳过所有的跳跃动画

409
00:17:36,790 --> 00:17:38,158
我们来看看如何做到这一点

410
00:17:38,892 --> 00:17:42,062
我们导航到
updateUIForJumpSucceeded函数

411
00:17:42,796 --> 00:17:46,200
我们可以看到这个函数
修改了一些颜色

412
00:17:46,266 --> 00:17:48,602
然后调用了
jumpAstronaut(animated:true)

413
00:17:49,069 --> 00:17:51,705
所以看起来我只需要调用
jumpAstronaut(animated:false)

414
00:17:52,072 --> 00:17:53,507
我可以更改代码并重新编译

415
00:17:53,574 --> 00:17:54,441
但正如我之前所说的

416
00:17:54,508 --> 00:17:56,777
我不喜欢为了调试目的
而改变我的代码

417
00:17:56,844 --> 00:17:59,813
如果我能避免这样做的话
所以我们来看看我将使用的技术

418
00:18:00,380 --> 00:18:01,849
我在这一行上设置一个断点

419
00:18:02,049 --> 00:18:05,052
让我们清除调试控制台
并通过点击宇航员

420
00:18:05,118 --> 00:18:06,320
进行一次新的跳跃

421
00:18:06,386 --> 00:18:07,721
现在我们在这一行暂停

422
00:18:08,088 --> 00:18:09,423
我需要让调试器

423
00:18:09,723 --> 00:18:13,093
将这行代码替换为
jumpAstronaut(animated:false)

424
00:18:13,627 --> 00:18:15,696
然而代码已经编译过了
我们无法取代它

425
00:18:15,896 --> 00:18:18,966
但我们可以做的是
让调试器跳过这一行

426
00:18:19,166 --> 00:18:20,567
不执行它 而是跳过它

427
00:18:20,634 --> 00:18:23,070
然后我们可以使用表达式来注入

428
00:18:23,270 --> 00:18:24,538
我们所希望的调用

429
00:18:25,038 --> 00:18:26,540
那么我们如何跳过一行代码呢

430
00:18:26,940 --> 00:18:29,409
我们把注意力放在这个绿色的
Thread 1

431
00:18:29,576 --> 00:18:30,410
注解标签上

432
00:18:30,477 --> 00:18:32,279
我们称之为指令指针

433
00:18:32,579 --> 00:18:34,615
它指向包含

434
00:18:34,681 --> 00:18:36,016
接下来会执行的指令的行

435
00:18:36,416 --> 00:18:38,719
这里的这个看起来像握柄的图标

436
00:18:39,286 --> 00:18:40,354
实际上就是一个握柄

437
00:18:40,521 --> 00:18:42,356
按住鼠标就可以移动它

438
00:18:42,723 --> 00:18:45,325
这样我就可以在暂停时更改指令指针

439
00:18:45,759 --> 00:18:47,794
我可以把它往下移动一行 然后放手

440
00:18:48,095 --> 00:18:50,430
接着Xcode
会显示一条可怕的消息

441
00:18:50,898 --> 00:18:52,799
它所说的基本就是

442
00:18:52,866 --> 00:18:55,002
巨大的权力会带来巨大的责任

443
00:18:55,269 --> 00:18:56,970
说实话
这是我今天告诉你们的

444
00:18:57,037 --> 00:18:58,071
最危险的功能

445
00:18:58,505 --> 00:19:02,109
这项操作是有风险的
因为调试器允许你移动指令指针

446
00:18:58,505 --> 00:19:02,109
这项操作是有风险的
因为调试器允许你移动指令指针

447
00:19:02,176 --> 00:19:03,577
到你想要的任何地方
它并不关心

448
00:19:03,710 --> 00:19:05,779
但它不能保证app的状态

449
00:19:05,846 --> 00:19:06,747
完好无损

450
00:19:07,147 --> 00:19:09,449
例如 这可能会造成内存管理问题

451
00:19:09,616 --> 00:19:12,686
当你试图引用尚未初始化的对象

452
00:19:12,953 --> 00:19:14,655
或过早释放对象时

453
00:19:15,255 --> 00:19:17,791
但既然这是高级调试演讲
所以我们知道

454
00:19:17,858 --> 00:19:18,692
我们在做什么

455
00:19:18,759 --> 00:19:19,893
让我们按下蓝色按钮

456
00:19:21,361 --> 00:19:22,963
现在我们跳过了那行代码

457
00:19:23,030 --> 00:19:24,064
在控制台中

458
00:19:24,131 --> 00:19:26,967
我们可以使用expression命令调用
jumpAstronaut(animated:false)

459
00:19:29,036 --> 00:19:31,038
现在我们点击继续
来看看这一切是否奏效

460
00:19:31,672 --> 00:19:35,809
游戏状态的确已更新
而且我们跳过了所有跳跃动画

461
00:19:37,244 --> 00:19:39,580
我希望每当我点击宇航员时都能这样

462
00:19:39,880 --> 00:19:42,616
所以我要配置这个断点
来为我做这件事

463
00:19:43,717 --> 00:19:47,487
首先我们需要一个
跳过一行代码的调试器操作

464
00:19:47,621 --> 00:19:49,489
它的命令是
thread jump

465
00:19:50,157 --> 00:19:51,491
再给它一个参数
--by 1

466
00:19:51,692 --> 00:19:55,229
这告诉调试器为当前线程

467
00:19:55,295 --> 00:19:56,230
跳过一行代码

468
00:19:56,763 --> 00:19:59,566
然后我们只需要调用表达式

469
00:19:59,633 --> 00:20:01,568
我们可以通过点击加号按钮来

470
00:19:59,633 --> 00:20:01,568
我们可以通过点击加号按钮来

471
00:20:01,969 --> 00:20:03,737
添加另一个命令操作

472
00:20:04,838 --> 00:20:08,208
expression
jumpAstronaut(animated:false)

473
00:20:08,876 --> 00:20:10,244
然后将其设置为自动继续

474
00:20:10,644 --> 00:20:14,014
我们这里有一个断点

475
00:20:14,081 --> 00:20:17,251
当运行到此行 但在执行此行之前

476
00:20:17,317 --> 00:20:18,752
断点将被触发

477
00:20:19,052 --> 00:20:21,688
它将执行跳过该行的命令

478
00:20:21,889 --> 00:20:24,124
然后使用表达式来调用

479
00:20:24,491 --> 00:20:26,560
我们想要调用的函数

480
00:20:27,294 --> 00:20:29,329
现在 如果我们点击宇航员

481
00:20:29,696 --> 00:20:31,832
我们可以快速推进游戏进展

482
00:20:31,899 --> 00:20:34,501
并跳过所有动画
从而轻松地重现我们的漏洞

483
00:20:35,302 --> 00:20:38,872
所以正如我所说的那样
游戏本应该在10次尝试后结束

484
00:20:38,939 --> 00:20:40,307
我们已经远远超过了它

485
00:20:40,641 --> 00:20:43,243
让我们来看看游戏状态

486
00:20:44,144 --> 00:20:46,380
它们都被保存在上面这个属性中

487
00:20:47,014 --> 00:20:47,981
即gamePlay

488
00:20:48,048 --> 00:20:50,217
所以我会在该属性上设置一个断点

489
00:20:50,684 --> 00:20:52,019
并执行一次新的跳跃

490
00:20:52,252 --> 00:20:54,922
现在我们在对该属性的
下一个引用处暂停

491
00:20:55,556 --> 00:20:58,759
我将使用po命令来查看
该对象的当前状态

492
00:20:59,159 --> 00:21:00,928
这里我们看到对这个

493
00:20:59,159 --> 00:21:00,928
这里我们看到对这个

494
00:21:01,228 --> 00:21:02,529
GamePlay对象的调试描述

495
00:21:02,963 --> 00:21:04,865
这里有一个自定义的调试描述

496
00:21:05,232 --> 00:21:07,601
所以值得指出的是
po命令能够获得

497
00:21:07,668 --> 00:21:09,536
对象的编程调试描述

498
00:21:09,937 --> 00:21:11,171
而且你可以自定义该描述

499
00:21:11,738 --> 00:21:13,240
来看看我们对GamePlay
做了什么

500
00:21:13,307 --> 00:21:14,641
如果我切换到源代码

501
00:21:14,975 --> 00:21:15,976
并滚动到底部

502
00:21:16,476 --> 00:21:19,379
你可以看到我们添加了一个扩展
以使GamePlay符合

503
00:21:19,446 --> 00:21:21,582
CustomDebugStringConvertible约束

504
00:21:22,149 --> 00:21:24,751
该约束要求你实现

505
00:21:24,885 --> 00:21:27,588
一个名为debugDescription的属性
并返回一个字符串

506
00:21:27,855 --> 00:21:30,224
你可以返回你喜欢的
任何用于调试的字符串

507
00:21:30,457 --> 00:21:33,327
来表示这个对象

508
00:21:34,027 --> 00:21:36,864
你也可以通过实现
debugDescription

509
00:21:36,930 --> 00:21:39,366
来对Objective-C对象
执行相同的操作

510
00:21:39,733 --> 00:21:41,835
将其与命令
p GamePlay对比

511
00:21:42,936 --> 00:21:44,137
p是另一种…

512
00:21:44,705 --> 00:21:46,773
或LLDB命令

513
00:21:47,107 --> 00:21:50,644
它使用LLDB的内置格式化程序
来表示对象

514
00:21:50,878 --> 00:21:53,080
因此这里我们看到了
同一个对象的两个表示

515
00:21:53,547 --> 00:21:56,683
并且默认格式化程序向你显示
完整限定类型名称

516
00:21:56,750 --> 00:21:59,920
内存地址
以及所有属性及其值的列表

517
00:22:00,354 --> 00:22:02,489
我们可在此看到
有一个maxAttempts属性

518
00:22:02,556 --> 00:22:03,857
其值被正确设置为10

519
00:22:04,525 --> 00:22:06,827
因此可能某处存在逻辑错误

520
00:22:07,027 --> 00:22:08,629
在attempts的值增加后

521
00:22:08,695 --> 00:22:11,865
没有正确判断出
它已经超过了最大值

522
00:22:12,199 --> 00:22:14,601
所以我想找到修改
attempts值的代码

523
00:22:14,668 --> 00:22:15,502
来看看其中的逻辑

524
00:22:16,303 --> 00:22:19,406
我将打开变量视图并展开视图控制器

525
00:22:19,473 --> 00:22:21,441
以查看其所有属性

526
00:22:21,508 --> 00:22:24,011
在底部我将在过滤器中
输入GamePlay

527
00:22:24,211 --> 00:22:25,345
来找到这个属性

528
00:22:25,679 --> 00:22:28,949
展开它的属性列表
然后选择attempts属性

529
00:22:29,716 --> 00:22:32,586
在这里打开其上下文菜单

530
00:22:32,953 --> 00:22:34,755
并选择
Watch “attempts”

531
00:22:36,256 --> 00:22:38,992
它所做的是创建一个所谓的观察点

532
00:22:39,626 --> 00:22:40,861
在断点导航器中

533
00:22:40,928 --> 00:22:42,095
在所有断点下面

534
00:22:42,296 --> 00:22:44,498
你会看到有一个叫做
Watchpoints的新组

535
00:22:44,565 --> 00:22:46,400
我们有一个attempts观察点

536
00:22:46,800 --> 00:22:48,635
观察点就像一个断点

537
00:22:48,836 --> 00:22:51,905
但它会在下一次变量的值改变时
暂停调试器

538
00:22:52,606 --> 00:22:55,576
现在我们可以移除这个属性断点
因为我们不再需要它

539
00:22:55,943 --> 00:22:56,944
然后点击继续

540
00:22:57,177 --> 00:22:58,979
现在我们已经在这个观察点停了下来

541
00:22:59,146 --> 00:23:01,782
并且我们找到了
修改attempts变量的代码

542
00:22:59,146 --> 00:23:01,782
并且我们找到了
修改attempts变量的代码

543
00:23:03,050 --> 00:23:05,285
我现在禁用这个观察点
因为我不再需要它

544
00:23:05,552 --> 00:23:07,888
我们看看这里的代码
当游戏正在进行时

545
00:23:07,955 --> 00:23:10,390
增加attempts
如跳跃成功则增加score

546
00:23:10,657 --> 00:23:13,093
我没有看到任何会检测
attempts是否已超过最大值

547
00:23:13,160 --> 00:23:16,496
并转换到游戏结束状态的逻辑

548
00:23:17,130 --> 00:23:19,166
所以我认为这就是需要改的地方

549
00:23:19,233 --> 00:23:20,734
但在我实际更改任何代码之前

550
00:23:20,934 --> 00:23:22,836
我想先测试我的假设

551
00:23:23,337 --> 00:23:25,105
所以在我更改任何代码之前

552
00:23:25,405 --> 00:23:28,408
我要创建一个断点
并配置它注入该更改

553
00:23:28,609 --> 00:23:30,077
以查看它是否修复了问题

554
00:23:30,444 --> 00:23:32,513
我可以再次添加一个
调试器命令行为

555
00:23:32,579 --> 00:23:33,514
和一个表达式

556
00:23:33,780 --> 00:23:37,818
我们要的是如果attempts
大于等于maxAttempts

557
00:23:38,252 --> 00:23:40,287
则将游戏状态更改为已结束

558
00:23:41,054 --> 00:23:42,389
并将其设为自动继续

559
00:23:42,956 --> 00:23:45,526
所以现在只需按下继续按钮
来测试一下

560
00:23:45,626 --> 00:23:46,660
是否真正解决了问题

561
00:23:46,793 --> 00:23:48,829
程序执行到这个断点

562
00:23:49,096 --> 00:23:50,364
注入代码
我们可以看到

563
00:23:50,430 --> 00:23:52,332
它确实修复了问题

564
00:23:52,799 --> 00:23:54,902
我想从游戏开始时验证一下

565
00:23:54,968 --> 00:23:57,337
我可以点击Play again
快速轻松地完成此操作

566
00:23:57,571 --> 00:23:59,540
并迅速进行10次尝试

567
00:23:59,940 --> 00:24:02,776
在第十次我们看到它确实检测到
游戏结束状态

568
00:23:59,940 --> 00:24:02,776
在第十次我们看到它确实检测到
游戏结束状态

569
00:24:02,843 --> 00:24:04,378
看起来这正是我们需要的修复

570
00:24:12,152 --> 00:24:14,254
别忘了将更改应用于你的代码

571
00:24:14,321 --> 00:24:17,357
我将代码复制出来
拖动断点以删除它

572
00:24:17,691 --> 00:24:19,593
然后将代码粘贴进去
看起来不错

573
00:24:20,327 --> 00:24:21,461
我们来勾掉这一项

574
00:24:21,528 --> 00:24:23,363
这个部分我们只剩下一个漏洞了

575
00:24:23,897 --> 00:24:26,266
即Attempts
和Score标签的布局

576
00:24:26,633 --> 00:24:30,137
现在这个app的布局工作
被留给了工程师们

577
00:24:30,404 --> 00:24:31,805
就像优秀的工程师一样

578
00:24:32,105 --> 00:24:35,108
我们找到了一个好位置
将它们填到顶角

579
00:24:35,509 --> 00:24:38,579
但是团队认为这不太合适

580
00:24:38,779 --> 00:24:40,447
他们将app退回
并要求我们再试一次

581
00:24:40,848 --> 00:24:44,351
所以我想模拟出
这些分数标签的新布局

582
00:24:44,651 --> 00:24:47,321
现在我可以打开我的图形app
并开始建模了

583
00:24:47,387 --> 00:24:49,423
但我是一名工程师
我喜欢用代码建模

584
00:24:49,656 --> 00:24:50,858
我其实是调试工程师

585
00:24:50,924 --> 00:24:54,027
所以我喜欢用实时app
和真实数据在调试器中建模

586
00:24:54,094 --> 00:24:55,262
我们看看如何做到这点

587
00:24:58,732 --> 00:25:02,703
让我们导航回去
并在jump函数中设置断点

588
00:24:58,732 --> 00:25:02,703
让我们导航回去
并在jump函数中设置断点

589
00:25:03,136 --> 00:25:05,772
我们首先需要找到一个

590
00:25:05,839 --> 00:25:07,274
可与其交互的视图的引用

591
00:25:07,708 --> 00:25:09,877
所以我要清空这里并打开它

592
00:25:10,244 --> 00:25:12,412
进行一次新的跳跃
然后调试器在

593
00:25:12,713 --> 00:25:15,382
视图控制器内的这个
jump函数中暂停

594
00:25:15,949 --> 00:25:18,585
所以如果你有一个视图的
属性或输出口

595
00:25:18,652 --> 00:25:20,320
那么这是会一个很好的引用

596
00:25:20,387 --> 00:25:22,656
但如果你没有
那你需要获得视图的内存地址

597
00:25:22,723 --> 00:25:24,892
因此让我向你展示一些
查找内存地址的方法

598
00:25:24,958 --> 00:25:27,561
以及如何仅通过内存地址来操作视图

599
00:25:28,195 --> 00:25:29,162
像我们之前说的那样

600
00:25:30,197 --> 00:25:32,599
调试描述包含一个自定义描述

601
00:25:32,900 --> 00:25:34,468
所以看一下视图控制器的视图

602
00:25:34,535 --> 00:25:37,104
我们可以看到UIView的
默认调试描述

603
00:25:37,437 --> 00:25:39,873
其中包含视图的类和内存地址

604
00:25:40,140 --> 00:25:44,645
所以一种方法就是
获取对象的调试描述

605
00:25:45,145 --> 00:25:48,315
由于我们有一个属性指向它
所以很容易得到这个信息

606
00:25:48,682 --> 00:25:52,085
但这个视图控制器视图
下面的所有视图该怎么办呢？

607
00:25:52,719 --> 00:25:54,121
我们需要查看视图层次结构

608
00:25:54,188 --> 00:25:57,090
一种方法是使用这里的这个按钮

609
00:25:57,157 --> 00:25:59,593
它会调用Xcode的
可视化视图调试器

610
00:25:59,927 --> 00:26:03,130
它将为层次结构拍摄快照
并为你提供3D分解视图

611
00:25:59,927 --> 00:26:03,130
它将为层次结构拍摄快照
并为你提供3D分解视图

612
00:26:03,197 --> 00:26:05,232
你可以用它来检查视图

613
00:26:05,666 --> 00:26:07,568
Sebastian稍后
会详细讨论这个问题

614
00:26:07,634 --> 00:26:09,169
所以我们来看看另一种方式

615
00:26:09,236 --> 00:26:11,338
这对于更简单的层次结构很有用

616
00:26:11,738 --> 00:26:13,907
并且只需在调试控制台中操作

617
00:26:14,708 --> 00:26:18,812
这就是使用UIView上的调试函数
recursiveDescription

618
00:26:20,214 --> 00:26:23,717
我们应该可以调用 po self.view.
.recursiveDescription()

619
00:26:24,751 --> 00:26:25,853
但这行不通

620
00:26:25,986 --> 00:26:26,820
为什么呢？

621
00:26:27,521 --> 00:26:30,257
recursiveDescription
仅用于调试目的

622
00:26:30,457 --> 00:26:33,894
它不是公共API的一部分
因此也不会被Swift扫描

623
00:26:34,328 --> 00:26:35,162
所以…

624
00:26:35,462 --> 00:26:38,165
Swift是一种严格的语言
不允许你调用

625
00:26:38,232 --> 00:26:39,733
尚未严格定义的函数

626
00:26:40,434 --> 00:26:41,935
然而Objective-C不同

627
00:26:42,102 --> 00:26:44,304
在Objective-C世界中
代码可以自由放纵的运行

628
00:26:44,438 --> 00:26:45,639
你可以做任何你想做的事

629
00:26:45,706 --> 00:26:48,509
我的意思是它是一种动态语言
所以你可以调用这样的函数

630
00:26:49,142 --> 00:26:50,277
所以我们要做的

631
00:26:50,410 --> 00:26:53,146
是告诉调试器使用
Objective-C语法

632
00:26:53,213 --> 00:26:55,516
来评估这个表达式

633
00:26:55,949 --> 00:27:00,087
实现这点的方法是
使用expression命令和选项参数-l objc

634
00:26:55,949 --> 00:27:00,087
实现这点的方法是
使用expression命令和选项参数-l objc

635
00:27:00,721 --> 00:27:02,723
这表明你即将
给expression命令

636
00:27:02,789 --> 00:27:05,092
一段Objective-C代码
即使你处于Swift框架中

637
00:27:06,793 --> 00:27:08,061
我们再加上-O

638
00:27:08,128 --> 00:27:09,863
来告诉它我们也想要调试描述

639
00:27:09,930 --> 00:27:11,298
就像用po一样

640
00:27:11,598 --> 00:27:14,134
再加上--以表示没有更多选项

641
00:27:14,902 --> 00:27:17,004
该行的其余部分仅仅是
原始表达式输入

642
00:27:17,471 --> 00:27:20,841
所以我们应该能够给它
这个方法调用的

643
00:27:20,908 --> 00:27:22,042
Objective-C格式

644
00:27:22,809 --> 00:27:24,244
不幸的是 这并不奏效

645
00:27:24,311 --> 00:27:25,746
其原因是这个表达式

646
00:27:25,812 --> 00:27:29,650
将为Objective-C
编译创建一个临时表达式上下文

647
00:27:29,883 --> 00:27:32,186
并且它不会继承
Swift框架中的所有变量

648
00:27:32,519 --> 00:27:33,854
尽管如此 还是有办法的

649
00:27:34,421 --> 00:27:36,089
如果我们把self.view
放到反引号中

650
00:27:36,390 --> 00:27:38,025
反引号就像预处理器一样

651
00:27:38,392 --> 00:27:41,228
它表示先评估其在当前帧中的内容

652
00:27:41,295 --> 00:27:43,397
并插入结果
然后我们可以评估其余部分

653
00:27:43,730 --> 00:27:45,299
现在我们可以得到递归描述了

654
00:27:52,005 --> 00:27:53,974
现在我们就可以看到所有视图的

655
00:27:54,041 --> 00:27:54,942
调试描述

656
00:27:55,342 --> 00:27:57,077
我对ScoreboardView
很感兴趣

657
00:27:57,144 --> 00:27:58,378
它承载着这些标签

658
00:27:58,512 --> 00:28:00,347
我们可以找到其中之一的内存地址

659
00:27:58,512 --> 00:28:00,347
我们可以找到其中之一的内存地址

660
00:28:00,647 --> 00:28:03,650
现在我们可以使用
po内存地址

661
00:28:03,717 --> 00:28:06,453
如果你是Objective-C开发者
你可能熟悉该命令

662
00:28:06,520 --> 00:28:08,255
这也行不通
那是因为Swift

663
00:28:08,322 --> 00:28:11,792
不会将数字视为指针

664
00:28:11,859 --> 00:28:13,126
并为你解引用

665
00:28:13,193 --> 00:28:16,396
所以需要在Objective-C
上下文中做到这一点

666
00:28:16,930 --> 00:28:18,565
我们可以做跟刚才同样的事情

667
00:28:18,932 --> 00:28:20,434
但我觉得这样更方便

668
00:28:20,634 --> 00:28:22,402
我喜欢将其简化为

669
00:28:22,469 --> 00:28:25,372
一个简单的命令

670
00:28:26,340 --> 00:28:28,709
所以我打算通过使用命令别名
来做到这一点

671
00:28:29,042 --> 00:28:30,711
我把这个命令称为poc

672
00:28:31,211 --> 00:28:32,312
我已创建了一个别名

673
00:28:32,379 --> 00:28:33,914
我能简单地poc那个内存地址

674
00:28:34,114 --> 00:28:36,149
并查看该对象的调试描述

675
00:28:36,750 --> 00:28:37,885
我想向你展示另一种方式

676
00:28:38,085 --> 00:28:41,955
来查看对象的描述
当你只有其内存地址的时候

677
00:28:42,322 --> 00:28:45,759
在Swift中你可以使用一个叫做
unsafeBitCast的函数

678
00:28:46,360 --> 00:28:48,061
给它一个内存地址
它不安全是因为

679
00:28:48,128 --> 00:28:50,931
它依赖你来提供正确的类型

680
00:28:51,231 --> 00:28:53,100
因此我给它
ScoreboardView.self

681
00:28:54,001 --> 00:28:57,471
现在我们看到我们可以使用
unsafeBitCast函数来查看一个对象的

682
00:28:57,538 --> 00:28:58,405
调试描述

683
00:28:59,139 --> 00:29:01,041
unsafeBitCast函数
的一个好处是

684
00:28:59,139 --> 00:29:01,041
unsafeBitCast函数
的一个好处是

685
00:29:01,108 --> 00:29:02,676
它返回一个经过类型转换的结果

686
00:29:02,943 --> 00:29:06,246
所以我们可以调用它的函数
和属性名称 例如.frame

687
00:29:06,780 --> 00:29:09,016
我想看一下它的中心点

688
00:29:09,349 --> 00:29:10,884
然后修改该中心点

689
00:29:10,951 --> 00:29:12,152
我们将其改为300

690
00:29:12,819 --> 00:29:15,088
现在我们可以看到
它已经变成了300

691
00:29:15,622 --> 00:29:18,258
但模拟器中的视图并没有移动

692
00:29:18,325 --> 00:29:19,159
为什么会这样呢？

693
00:29:19,693 --> 00:29:20,727
我们在调试器中暂停了

694
00:29:20,794 --> 00:29:24,198
所以Core Animation
目前不会将任何视图模块更改

695
00:29:24,264 --> 00:29:25,432
应用到屏幕的帧缓冲区

696
00:29:25,499 --> 00:29:27,534
但我们可以要求Core Animation
为我们做这件事

697
00:29:28,001 --> 00:29:31,572
只需使用表达式
CAtransaction.flush()

698
00:29:33,106 --> 00:29:35,976
这告诉Core Animation
更新屏幕的帧缓冲区

699
00:29:42,049 --> 00:29:45,252
现在我可以用这两行代码
来修复新的位置

700
00:29:45,319 --> 00:29:47,921
继续刷新屏幕
并四处移动该视图

701
00:29:47,988 --> 00:29:49,590
实际上 我觉得将这些都包装到

702
00:29:49,656 --> 00:29:51,992
一条命令中来移动视图会很方便

703
00:29:52,092 --> 00:29:54,094
所以我将这么做

704
00:29:54,661 --> 00:29:55,662
我们来看看

705
00:29:56,196 --> 00:29:58,932
我将切换到终端
并打开一个Python文件

706
00:29:59,666 --> 00:30:00,968
为什么使用Python文件呢？

707
00:29:59,666 --> 00:30:00,968
为什么使用Python文件呢？

708
00:30:01,368 --> 00:30:03,770
LLDB可以使用
Python编写脚本

709
00:30:03,837 --> 00:30:06,473
你可以完全访问LLDB API

710
00:30:06,907 --> 00:30:11,645
我创建了LLDB Python
脚本实现一个nudge命令

711
00:30:11,845 --> 00:30:14,081
它需要一个x偏移量、一个y偏移量
和一个视图表达式

712
00:30:14,314 --> 00:30:16,850
你可以在调试器中暂停时
使用它来移动视图

713
00:30:17,518 --> 00:30:18,952
它可能看起来很长

714
00:30:19,019 --> 00:30:20,821
但大部分都是参数解析

715
00:30:21,288 --> 00:30:24,258
其位于中间的核心部分只是在调用

716
00:30:24,324 --> 00:30:26,126
我们原来手动调用的表达式

717
00:30:26,760 --> 00:30:29,229
不幸的是我们没有时间
详细研究这个脚本

718
00:30:29,463 --> 00:30:30,931
但我们会将其放到网上以供下载

719
00:30:30,998 --> 00:30:33,467
以便你可以看到它是如何工作的
并以此为基础

720
00:30:33,567 --> 00:30:35,269
开发你自己的自定义调试命令

721
00:30:36,303 --> 00:30:37,471
让我向你展示如何

722
00:30:38,939 --> 00:30:40,307
启用这样的脚本

723
00:30:40,574 --> 00:30:42,643
只需编辑你的主目录中的

724
00:30:43,210 --> 00:30:44,344
.lldb文件…

725
00:30:44,912 --> 00:30:47,181
并添加一行
command script import

726
00:30:47,714 --> 00:30:50,484
我也想添加一些我觉得方便的别名

727
00:30:50,751 --> 00:30:52,886
比如我之前创建的poc别名

728
00:30:53,120 --> 00:30:54,855
和一个用于刷新事务的别名

729
00:30:54,988 --> 00:30:56,290
我想我会记住这个

730
00:31:00,127 --> 00:31:03,096
我将复制command script import
以便我们可以直接将其粘贴到

731
00:31:03,363 --> 00:31:05,999
调试会话以免重新启动该会话

732
00:31:06,233 --> 00:31:07,768
现在我们有了一个
叫做nudge的命令

733
00:31:08,202 --> 00:31:12,506
现在我可以 比方说
水平移动0点 垂直-5点

734
00:31:12,940 --> 00:31:14,708
为其提供一个视图的内存地址

735
00:31:15,008 --> 00:31:18,011
并开始在模拟器中四处移动它

736
00:31:26,720 --> 00:31:29,857
关于LLDB的一个很棒的地方在于
如果你只是在空行上按回车

737
00:31:29,923 --> 00:31:31,992
它会重复执行上一行
所以非常适合移动

738
00:31:32,826 --> 00:31:35,062
我可以将它稍微推向右侧

739
00:31:35,128 --> 00:31:36,263
让它看起来更好一点

740
00:31:36,496 --> 00:31:38,332
然后我们来移动另一个视图

741
00:31:38,398 --> 00:31:41,935
我们可以给它任何视图表达式

742
00:31:42,336 --> 00:31:43,971
比如这个attemptsView

743
00:31:44,371 --> 00:31:47,040
nudge的另一个特点是
一旦你给它一个视图表达式

744
00:31:47,107 --> 00:31:48,842
下次你就不必重复它

745
00:31:50,244 --> 00:31:52,379
它会记住该视图并将命令应用于

746
00:31:53,413 --> 00:31:54,681
你上一次指定的视图

747
00:31:54,748 --> 00:31:55,983
这样看起来很好

748
00:31:56,049 --> 00:31:57,651
这是一个比以前更好的布局

749
00:31:57,718 --> 00:31:59,319
现在我能做的就是获取

750
00:32:00,254 --> 00:32:01,889
nudge提供的信息

751
00:32:01,955 --> 00:32:04,124
例如应用于该视图的相对于

752
00:32:04,191 --> 00:32:05,759
其原始中心点的总偏移量

753
00:32:06,093 --> 00:32:07,194
然后是你的框架值

754
00:32:07,394 --> 00:32:11,198
我可以回到代码并修改布局代码
或我的自动布局约束

755
00:32:11,398 --> 00:32:14,067
我轻松地为自己的场景
构建了一种新的布局

756
00:32:15,969 --> 00:32:17,437
最后要做的事情是

757
00:32:17,938 --> 00:32:21,175
首先别忘了勾掉该漏洞
这非常重要

758
00:32:22,509 --> 00:32:25,379
然后在重新启动或编译运行之前
要做的最后一件事

759
00:32:25,445 --> 00:32:29,116
是禁用或删除任何

760
00:32:29,183 --> 00:32:30,217
注入表达式的断点

761
00:32:30,284 --> 00:32:32,386
因为你不希望这些代码被执行两次

762
00:32:32,986 --> 00:32:35,355
选择它们或它们所在的组
并点击删除

763
00:32:35,455 --> 00:32:36,790
是删除这些内容的快速方法

764
00:32:37,558 --> 00:32:39,726
这些都是一些调试技巧

765
00:32:39,793 --> 00:32:42,196
我喜欢用它们来增强
我的调试工作流程

766
00:32:43,197 --> 00:32:48,068
请注意我们如何诊断和修复
所有四个错误

767
00:32:48,135 --> 00:32:50,604
而无需重新编译或重新运行

768
00:32:51,271 --> 00:32:54,875
这可以节省大量的时间
特别是对于复杂的项目

769
00:32:55,142 --> 00:32:59,246
并且在尝试解决难以重现的漏洞时
可能至关重要

770
00:32:59,680 --> 00:33:01,348
非常感谢你们与我结对编程

771
00:32:59,680 --> 00:33:01,348
非常感谢你们与我结对编程

772
00:33:01,415 --> 00:33:03,116
希望你们喜欢它
并且可以在调试中

773
00:33:03,183 --> 00:33:04,518
使用这些技巧

774
00:33:15,729 --> 00:33:17,264
我想快速回顾一下

775
00:33:17,331 --> 00:33:19,867
刚才谈到的所有的

776
00:33:20,767 --> 00:33:22,436
功能和技巧

777
00:33:23,003 --> 00:33:25,739
首先 我们看到了
如何使用Xcode行为

778
00:33:25,806 --> 00:33:27,407
来调出一个专门调试选项卡

779
00:33:27,474 --> 00:33:30,410
以及如何使用LLDB表达式
修改程序状态

780
00:33:31,011 --> 00:33:33,881
我们可以在调试器命令中
使用自动继续断点

781
00:33:33,947 --> 00:33:35,182
来实时注入代码

782
00:33:35,616 --> 00:33:38,418
我们还可以使用命令
breakpoint set --one-shot

783
00:33:38,485 --> 00:33:40,087
创建依赖断点配置

784
00:33:40,287 --> 00:33:42,623
以作为设置另一个断点的
调试器命令行为

785
00:33:43,457 --> 00:33:45,025
即使在汇编帧中

786
00:33:45,092 --> 00:33:47,494
我们可以很容易使用
po $arg1 $arg2等

787
00:33:47,561 --> 00:33:49,863
来检查函数的参数

788
00:33:50,230 --> 00:33:52,065
我们也可以通过拖动指令指针

789
00:33:52,266 --> 00:33:55,469
或使用命令thread jump
来跳过代码行

790
00:33:56,270 --> 00:33:57,938
我们可以在使用观察点的变量
被修改时

791
00:33:58,005 --> 00:33:59,973
请求调试器暂停

792
00:34:01,208 --> 00:34:04,745
我们甚至可以使用
表达式expression -l objc

793
00:34:04,978 --> 00:34:07,047
来在Swift框架中
执行Objective-C代码

794
00:34:08,348 --> 00:34:11,150
我们可以使用 expression
CATransition.flush()

795
00:34:11,217 --> 00:34:13,187
将视图更改直接刷新到屏幕上

796
00:34:13,286 --> 00:34:15,289
即使是在调试器中暂停时

797
00:34:16,056 --> 00:34:18,958
你还可以添加自定义LLDB命令

798
00:34:19,025 --> 00:34:22,429
无论是给常用命令设置别名

799
00:34:23,030 --> 00:34:26,366
还是使用
LLDB Python脚本

800
00:34:26,433 --> 00:34:28,268
完全自定义并创建自己的命令

801
00:34:28,768 --> 00:34:30,704
别忘了访问我们的演讲网站

802
00:34:30,804 --> 00:34:33,473
我们会尽快发布这个nudge脚本
以便你可以下载它

803
00:34:33,706 --> 00:34:35,943
研究它并将其用作
你自己的命令的基础

804
00:34:38,212 --> 00:34:40,246
还有一件事我想和你们提一下

805
00:34:40,313 --> 00:34:42,983
就是当前的LLDB打印命令

806
00:34:43,417 --> 00:34:44,685
你可能已经很熟悉po了

807
00:34:44,751 --> 00:34:46,186
在演示中我们多次用到它

808
00:34:46,420 --> 00:34:47,721
我们看到po

809
00:34:47,888 --> 00:34:49,755
会请求对象的调试描述

810
00:34:49,857 --> 00:34:51,158
而且你可以自定义该描述

811
00:34:51,391 --> 00:34:53,293
那是因为po只是一个
以下命令的别名

812
00:34:53,527 --> 00:34:55,629
expression
--object-description

813
00:34:56,864 --> 00:34:58,632
或expression -O

814
00:34:59,366 --> 00:35:01,268
与p命令相比

815
00:34:59,366 --> 00:35:01,268
与p命令相比

816
00:35:01,335 --> 00:35:03,036
p只是expression命令
的别名

817
00:35:03,637 --> 00:35:07,841
它使用LLDB的内置格式化程序

818
00:35:07,908 --> 00:35:08,909
来显示对象的表示

819
00:35:10,043 --> 00:35:13,347
需要知道的第三个命令是
frame variable

820
00:35:13,614 --> 00:35:16,149
它与前两个的不同之处在于
它完全不需要编译

821
00:35:16,216 --> 00:35:17,684
和评估表达式

822
00:35:17,918 --> 00:35:20,087
它只是直接从内存中
读取变量中的值

823
00:35:20,320 --> 00:35:23,524
然后使用LLDB的内置格式化程序

824
00:35:24,157 --> 00:35:26,760
所以选择使用哪个命令
其实取决于个人喜好

825
00:35:26,827 --> 00:35:29,062
以及你希望在调试时看到的信息类型

826
00:35:29,763 --> 00:35:32,432
但重要的是要记住
如果你遇到这种情况

827
00:35:32,833 --> 00:35:37,204
即当表达式失败时
po和p可能无法工作

828
00:35:37,471 --> 00:35:39,573
如果你需要检查当前帧中的变量

829
00:35:39,806 --> 00:35:41,575
那么frame variable
应该还能正常工作

830
00:35:44,178 --> 00:35:46,480
接下来 我想将话筒
交给Sebastian

831
00:35:46,780 --> 00:35:49,383
他会告诉你一些高级视图调试技术

832
00:35:49,449 --> 00:35:50,317
谢谢

833
00:35:55,422 --> 00:35:56,490
谢谢你 Chris

834
00:35:58,725 --> 00:36:00,294
我很高兴能够向你展示…

835
00:35:58,725 --> 00:36:00,294
我很高兴能够向你展示…

836
00:36:01,228 --> 00:36:04,097
关于如何充分利用
Xcode视图调试器的提示和技巧

837
00:36:04,164 --> 00:36:06,700
我们也会看看我们
为Xcode 10所做的改进

838
00:36:07,267 --> 00:36:10,137
为采用macOS Mojave
暗色外观的Mac app

839
00:36:10,204 --> 00:36:14,141
的调试提供更好的体验

840
00:36:14,808 --> 00:36:16,844
我们将在一个演示中看到这点

841
00:36:17,978 --> 00:36:19,346
让我切换到演示机

842
00:36:20,714 --> 00:36:23,684
我将使用与Chris刚才使用的
相同的项目

843
00:36:23,750 --> 00:36:27,054
并且你已经看到
我们还有两个错误需要解决

844
00:36:29,790 --> 00:36:32,492
但是我不打算使用iOS app

845
00:36:32,626 --> 00:36:33,927
我将使用Mac app

846
00:36:34,661 --> 00:36:37,664
我们可以在这里看到
Solar System app的Mac版本

847
00:36:38,131 --> 00:36:40,000
它在暗色模式下看起来很不错

848
00:36:41,168 --> 00:36:43,070
但有两个漏洞我们需要解决掉

849
00:36:43,737 --> 00:36:47,307
首先 星球图像没有正确水平居中

850
00:36:47,875 --> 00:36:49,276
这是一个非常明显的漏洞

851
00:36:49,409 --> 00:36:51,812
你可以看到在右边
这张地球图片

852
00:36:52,012 --> 00:36:53,313
被移到右侧

853
00:36:53,814 --> 00:36:55,649
我们将会看看这个问题

854
00:36:55,916 --> 00:36:58,252
第二个漏洞是

855
00:36:58,418 --> 00:37:01,021
在暗色模式下
弹出框中的文本不可读

856
00:36:58,418 --> 00:37:01,021
在暗色模式下
弹出框中的文本不可读

857
00:37:01,221 --> 00:37:03,056
我们来看看这是指的是什么

858
00:37:03,724 --> 00:37:04,691
当我切换到这个app时

859
00:37:05,225 --> 00:37:07,060
我可以显示轨道细节

860
00:37:07,127 --> 00:37:08,729
信息显示在弹出框中

861
00:37:09,129 --> 00:37:11,365
你可以看到顶部的标签清晰可见

862
00:37:11,431 --> 00:37:14,067
然而底部的标签很难阅读

863
00:37:14,134 --> 00:37:15,769
我必须通过选择文本来阅读它

864
00:37:16,670 --> 00:37:18,672
所以这些是
我们必须要解决的两个漏洞

865
00:37:19,306 --> 00:37:21,508
让我隐藏待办事项列表
然后我们开始吧

866
00:37:22,342 --> 00:37:24,444
所以我要使用
Xcode捕获该app的

867
00:37:24,511 --> 00:37:26,146
视图层次结构

868
00:37:26,680 --> 00:37:27,915
然后检查它

869
00:37:28,515 --> 00:37:30,717
我们会定位问题
然后希望能够修复它

870
00:37:30,784 --> 00:37:31,885
我们就能去喝啤酒了

871
00:37:32,819 --> 00:37:35,956
问题是当我切换到Xcode
以捕捉视图层次结构时

872
00:37:36,190 --> 00:37:37,724
这个弹出框将会消失

873
00:37:37,791 --> 00:37:40,093
因为app进入了后台

874
00:37:40,527 --> 00:37:42,529
因此我们将无法捕获其视图层次结构

875
00:37:43,230 --> 00:37:45,165
我们必须要在app处于活动状态时

876
00:37:45,299 --> 00:37:46,567
来对app进行捕捉

877
00:37:46,867 --> 00:37:48,569
我会向你展示做到这点的两种方法

878
00:37:49,903 --> 00:37:53,006
你可以看到当我切换到Xcode时
这个弹出框如何消失

879
00:37:54,508 --> 00:37:55,976
首先 我们可以使用触摸栏

880
00:37:56,243 --> 00:37:59,012
我会通过从Xcode的窗口菜单
调出触摸栏模拟器

881
00:37:59,079 --> 00:38:00,347
来向你展示它的样子

882
00:37:59,079 --> 00:38:00,347
来向你展示它的样子

883
00:38:00,781 --> 00:38:02,182
我将切换回
Solar System app

884
00:38:02,249 --> 00:38:03,784
并再次调出弹出框

885
00:38:04,585 --> 00:38:05,686
然后看看触摸栏

886
00:38:05,752 --> 00:38:07,821
你可以看到这里有个喷雾罐图标

887
00:38:08,422 --> 00:38:09,823
当我在触摸栏上点击它时

888
00:38:09,890 --> 00:38:12,860
你可以看到Xcode在其调试栏中

889
00:38:13,493 --> 00:38:15,429
提供的该调试选项的子集

890
00:38:15,996 --> 00:38:18,932
因此从触摸栏访问这些工具非常方便

891
00:38:19,399 --> 00:38:22,636
如你所见 我可以在Xcode
处于背景中的情况下调出它们

892
00:38:22,736 --> 00:38:24,771
因此你甚至可以在以全屏模式

893
00:38:24,872 --> 00:38:26,507
开发app时访问它们

894
00:38:27,474 --> 00:38:30,377
这其中一个选项允许我捕捉

895
00:38:30,944 --> 00:38:31,812
视图的层次结构

896
00:38:31,879 --> 00:38:32,713
我不打算这样做

897
00:38:32,779 --> 00:38:35,249
因为我知道不是每个人都有
带触摸栏的Mac

898
00:38:35,315 --> 00:38:36,884
所以我会告诉你另一种方法

899
00:38:38,151 --> 00:38:39,253
我要关闭模拟器

900
00:38:39,319 --> 00:38:42,022
我将使用命令点击

901
00:38:42,489 --> 00:38:45,192
来点击Xcode的调试栏中的按钮

902
00:38:46,493 --> 00:38:48,061
命令点击是一个系统手势

903
00:38:48,161 --> 00:38:51,431
它允许你在不激活app的情况下

904
00:38:51,498 --> 00:38:52,799
执行鼠标事件

905
00:38:53,967 --> 00:38:56,036
所以这允许我们

906
00:38:56,837 --> 00:38:58,505
调用对视图层次结构的捕获

907
00:38:58,739 --> 00:39:01,742
调试器在app仍处于活动状态时
将其暂停

908
00:38:58,739 --> 00:39:01,742
调试器在app仍处于活动状态时
将其暂停

909
00:39:02,075 --> 00:39:03,877
我们可以看到用户界面仍然显示

910
00:39:04,077 --> 00:39:07,014
就好像app还在屏幕最前面
并且弹出框没有消失

911
00:39:07,447 --> 00:39:09,583
如果你想知道
为什么那个旋转的光标会出现

912
00:39:09,650 --> 00:39:11,418
这是因为app在调试器中暂停

913
00:39:11,485 --> 00:39:13,287
并且不再响应鼠标事件

914
00:39:14,755 --> 00:39:15,789
现在你可能在想

915
00:39:15,856 --> 00:39:17,457
如果我们看看这里的视图调试器

916
00:39:18,058 --> 00:39:19,560
为什么弹出框不可见呢

917
00:39:20,360 --> 00:39:22,396
别担心 视图层次结构已被捕获

918
00:39:22,462 --> 00:39:24,565
当我们谈到那个漏洞的时候

919
00:39:24,631 --> 00:39:25,832
再看看该如何查看弹出框

920
00:39:26,066 --> 00:39:28,001
但首先我想看看
这个ImageView的

921
00:39:28,068 --> 00:39:29,036
布局问题

922
00:39:29,770 --> 00:39:32,372
我先选择这个图像视图
让我放大一点

923
00:39:33,173 --> 00:39:35,375
当我们看一下右侧的内容时

924
00:39:35,843 --> 00:39:39,479
我们可以看到这是一个
_NSImageViewSimpleImageView

925
00:39:39,746 --> 00:39:42,316
这个下划线前缀

926
00:39:42,749 --> 00:39:46,220
通常暗示这是来自系统框架的内部类

927
00:39:46,520 --> 00:39:48,322
而不是我们在代码或界面构建器中

928
00:39:48,388 --> 00:39:51,658
设置图像视图时所使用的类

929
00:39:51,925 --> 00:39:54,561
我们来看看这个对象
在视图层次结构中的样子

930
00:39:54,628 --> 00:39:56,563
我可以通过点击
Navigate菜单并选择

931
00:39:56,897 --> 00:39:58,565
Reveal in Debug Navigator
来做到这一点

932
00:39:58,999 --> 00:40:00,334
我们现在可以在左侧

933
00:39:58,999 --> 00:40:00,334
我们现在可以在左侧

934
00:40:00,400 --> 00:40:03,337
看到它以及它的父视图和子视图

935
00:40:04,538 --> 00:40:06,974
我们能看到其父视图为
NSImageView

936
00:40:07,040 --> 00:40:08,509
这就是我们正在寻找的

937
00:40:08,575 --> 00:40:11,378
我们也看到其父视图
是PlanetGlobeView

938
00:40:11,879 --> 00:40:15,616
以及PlanetGlobeView的父视图
是NSVisualEffectView

939
00:40:16,950 --> 00:40:18,285
现在我要选择这个图像视图

940
00:40:19,186 --> 00:40:22,990
我们可以在右侧看到
该图像视图的其他属性

941
00:40:23,557 --> 00:40:25,192
我们来看看这个视图的布局

942
00:40:25,759 --> 00:40:27,461
我在这个app中使用了自动布局

943
00:40:27,694 --> 00:40:29,830
所以我想看看其自动布局约束

944
00:40:30,163 --> 00:40:32,366
我可以使用这个按钮来显示约束

945
00:40:33,734 --> 00:40:35,402
现在我们可以看到

946
00:40:35,469 --> 00:40:37,437
会影响此视图布局的所有约束

947
00:40:38,539 --> 00:40:39,840
你可以看到 例如

948
00:40:39,907 --> 00:40:41,475
此处的宽高比约束

949
00:40:41,975 --> 00:40:45,579
还有这条垂直线
这是一个对齐约束

950
00:40:46,513 --> 00:40:48,282
当我选择这个约束时

951
00:40:48,348 --> 00:40:50,884
我们可以在右侧看到其中所有属性

952
00:40:51,251 --> 00:40:52,619
现在 如果你想知道

953
00:40:52,686 --> 00:40:54,521
为什么视图调试器只显示线框

954
00:40:54,755 --> 00:40:56,990
这是因为它只显示特定视图的内容

955
00:40:57,057 --> 00:40:59,626
该视图需要处于所选视图的布局中

956
00:40:59,993 --> 00:41:02,696
由于所有这些视图本身都没有内容

957
00:40:59,993 --> 00:41:02,696
由于所有这些视图本身都没有内容

958
00:41:03,096 --> 00:41:04,565
所以我们目前只显示线框

959
00:41:05,766 --> 00:41:07,701
选择约束后

960
00:41:07,968 --> 00:41:10,103
让我们来看看右侧的信息

961
00:41:10,470 --> 00:41:14,274
我们可以看到
它与图像视图的水平中心对齐

962
00:41:14,708 --> 00:41:16,844
也与PlanetGlobeView的
水平中心对齐

963
00:41:16,910 --> 00:41:18,879
并且它以常量0进行对齐

964
00:41:19,012 --> 00:41:21,481
所以它在其父视图中水平居中对齐

965
00:41:22,449 --> 00:41:26,787
现在我们从调试导航器中
选中PlanetGlobeView

966
00:41:27,087 --> 00:41:29,823
我们可以看到它向左侧稍大一些

967
00:41:30,190 --> 00:41:31,425
但它在右侧对齐

968
00:41:31,491 --> 00:41:32,926
所以这有点奇怪

969
00:41:32,993 --> 00:41:35,395
因为我们刚刚看到了
能够正确对齐的约束

970
00:41:35,596 --> 00:41:37,097
即准确的水平居中

971
00:41:37,798 --> 00:41:39,933
但我们在视图调试器中
看到的却不是这样

972
00:41:40,133 --> 00:41:41,568
我们来看看
PlanetGlobeView的约束

973
00:41:41,835 --> 00:41:44,605
希望能够理解正在发生的事情

974
00:41:45,539 --> 00:41:47,374
我在这里选择前沿约束

975
00:41:47,441 --> 00:41:49,042
再次看看其信息

976
00:41:49,309 --> 00:41:52,112
我们可以看到
PlanetGlobeView的前沿

977
00:41:52,412 --> 00:41:55,015
与NSVisualEffectView
的前沿对齐

978
00:41:55,082 --> 00:41:56,517
而后者是在父视图中的

979
00:41:56,884 --> 00:41:59,253
所以它只是相对于它的父视图
插入进去

980
00:41:59,620 --> 00:42:01,655
并且它以常量30这样做

981
00:41:59,620 --> 00:42:01,655
并且它以常量30这样做

982
00:42:01,955 --> 00:42:02,923
这还算合理

983
00:42:03,390 --> 00:42:04,925
然后这个后沿约束

984
00:42:06,460 --> 00:42:08,795
将PlanetGlobeView
的后沿

985
00:42:08,996 --> 00:42:10,531
与父视图的后沿对齐

986
00:42:10,898 --> 00:42:12,900
它也以常数30这样做

987
00:42:13,367 --> 00:42:14,668
现在这个约束

988
00:42:15,068 --> 00:42:16,703
没有附加到右侧的任何内容

989
00:42:16,770 --> 00:42:18,338
这有点值得怀疑
这让我在想

990
00:42:18,405 --> 00:42:19,740
我们是否在此看到了整个图景

991
00:42:20,207 --> 00:42:21,942
在这种情况下
通常有一个好主意

992
00:42:22,009 --> 00:42:24,044
即查看是否有任何内容被裁剪了

993
00:42:24,111 --> 00:42:25,445
而我们默认看不到它们

994
00:42:26,013 --> 00:42:29,183
你可以使用这里的这个按钮
来显示裁剪内容

995
00:42:30,117 --> 00:42:31,485
现在当我启用此功能时

996
00:42:31,552 --> 00:42:34,621
你可以看到PlanetGlobeView
实际上向右延伸

997
00:42:34,688 --> 00:42:35,923
超过了窗口范围

998
00:42:36,323 --> 00:42:38,058
现在水平居中约束变得合理了

999
00:42:38,592 --> 00:42:41,361
因为它实际上正确的在父视图中

1000
00:42:41,528 --> 00:42:42,896
水平居中了

1001
00:42:43,263 --> 00:42:46,066
只是父视图延伸到了窗口之外

1002
00:42:46,900 --> 00:42:48,969
这是一个很常见的问题
如果你在代码中设置约束

1003
00:42:49,036 --> 00:42:51,471
你不小心交换了第一个和第二个项目

1004
00:42:51,538 --> 00:42:53,373
从而导致布局方向错误

1005
00:42:53,440 --> 00:42:55,409
或者你不小心弄反了常量

1006
00:42:55,609 --> 00:42:59,246
在这个例子中
我们使用了30而不是-30

1007
00:42:59,446 --> 00:43:01,215
来将其插入左侧

1008
00:42:59,446 --> 00:43:01,215
来将其插入左侧

1009
00:43:01,415 --> 00:43:04,051
所以我想要做的就是尝试反转常量

1010
00:43:04,117 --> 00:43:06,587
进行修复 我将使用
与Chris使用的相同技巧

1011
00:43:06,653 --> 00:43:10,324
简单的在LLDB中应用它

1012
00:43:11,425 --> 00:43:13,727
选中这个约束

1013
00:43:16,864 --> 00:43:19,633
再选择Edit->Copy

1014
00:43:20,334 --> 00:43:23,170
再调出底部的控制台区域

1015
00:43:23,937 --> 00:43:26,106
刚才我复制的内容

1016
00:43:27,007 --> 00:43:29,676
是所选对象的经过类型转换的指针

1017
00:43:29,743 --> 00:43:32,479
这适用于你在视图调试器中
以及内存图形调试器中

1018
00:43:32,546 --> 00:43:34,114
选择的所有对象

1019
00:43:34,181 --> 00:43:36,283
这使得在控制台中使用它们非常方便

1020
00:43:36,817 --> 00:43:37,751
让我们…

1021
00:43:42,022 --> 00:43:42,856
谢谢

1022
00:43:43,257 --> 00:43:44,391
让我们打印调试描述

1023
00:43:44,458 --> 00:43:47,728
我们可以确定这个常数的确是正30

1024
00:43:48,161 --> 00:43:50,264
这也是我们在信息栏中看到的

1025
00:43:50,764 --> 00:43:52,799
所以让我们将常数设置为-30

1026
00:43:53,233 --> 00:43:56,503
输入e
这是expression超短缩写

1027
00:43:56,904 --> 00:44:00,607
转换指针的类型
然后setConstant

1028
00:43:56,904 --> 00:44:00,607
转换指针的类型
然后setConstant

1029
00:44:01,675 --> 00:44:02,843
为-30

1030
00:44:03,710 --> 00:44:06,446
我们遇到与Chris
在上个app中看到的相同问题

1031
00:44:06,513 --> 00:44:08,115
即app没有及时更新

1032
00:44:08,549 --> 00:44:11,018
所以我必须要做的是

1033
00:44:11,285 --> 00:44:13,020
执行一个命令

1034
00:44:13,086 --> 00:44:16,056
来让暂停的app

1035
00:44:17,257 --> 00:44:18,926
调度其用户界面的更新

1036
00:44:19,693 --> 00:44:21,995
我可以使用
Chris刚才添加的方便命令

1037
00:44:23,230 --> 00:44:25,632
我可以在这里找到命令

1038
00:44:26,333 --> 00:44:28,402
现在我们可以看到地球图像

1039
00:44:28,468 --> 00:44:30,003
正确地水平居中了

1040
00:44:30,070 --> 00:44:32,005
所以反转常量是正确的修复方法

1041
00:44:32,439 --> 00:44:36,109
现在我们能够确认这一点
所以让我们在代码中应用这个改变

1042
00:44:37,978 --> 00:44:39,179
选中约束后

1043
00:44:39,379 --> 00:44:41,014
你可以在右侧看到

1044
00:44:41,548 --> 00:44:42,850
这个回溯信息

1045
00:44:42,950 --> 00:44:45,319
那就是约束的分配回溯路径

1046
00:44:45,385 --> 00:44:47,754
它准确告诉我它被分配在哪个框中

1047
00:44:47,988 --> 00:44:49,756
所以它可以让我直接找到

1048
00:44:50,257 --> 00:44:51,758
创建该约束的相应代码

1049
00:44:52,726 --> 00:44:55,662
为了显示这个回溯信息

1050
00:44:55,896 --> 00:44:57,731
你必须启用
Malloc Stack日志

1051
00:44:57,931 --> 00:44:59,800
让我告诉你如何启用它

1052
00:45:00,334 --> 00:45:02,636
在此找到你的方案
然后选择Edit Scheme

1053
00:45:03,770 --> 00:45:05,239
并在Scheme Options的

1054
00:45:05,372 --> 00:45:07,641
Diagnostics选项卡中

1055
00:45:07,808 --> 00:45:10,511
在Logging选项处
可启用Malloc Stack日志

1056
00:45:10,911 --> 00:45:12,713
并选中 All Allocations
and Free History

1057
00:45:13,580 --> 00:45:16,216
这将为你提供这些方便的
分配回溯信息 即视图调试器

1058
00:45:16,283 --> 00:45:18,151
和Xcode的内存图像调试器中的

1059
00:45:18,218 --> 00:45:20,053
所选对象的分配回溯信息

1060
00:45:21,088 --> 00:45:23,991
现在当我将鼠标悬停在这个堆栈上时

1061
00:45:24,324 --> 00:45:26,894
我们可以看到该框的全名

1062
00:45:27,594 --> 00:45:31,231
我们可以看到
这是SceneViewController中的

1063
00:45:31,298 --> 00:45:32,533
setupPlanetGlobeLayout方法

1064
00:45:33,467 --> 00:45:36,436
我可以使用此跳转箭头

1065
00:45:36,837 --> 00:45:38,138
跳到这部分代码

1066
00:45:39,139 --> 00:45:41,775
我通过按住Shift-Control-Option键
来做到这点

1067
00:45:41,975 --> 00:45:44,011
这将打开这个导航框

1068
00:45:44,211 --> 00:45:46,947
并允许我在新窗口中打开此文件

1069
00:45:48,715 --> 00:45:50,517
现在你可以看到分配约束的这行代码

1070
00:45:50,584 --> 00:45:52,786
被高亮显示了

1071
00:45:52,853 --> 00:45:54,154
我们看到值为30的常量

1072
00:45:54,221 --> 00:45:55,756
我可以将其反转为-30

1073
00:45:56,490 --> 00:45:58,325
保存该文件并关闭它

1074
00:45:58,392 --> 00:45:59,793
我们解决了第一个漏洞

1075
00:46:01,261 --> 00:46:04,498
完美
第二个漏洞是我们无法看清

1076
00:46:04,932 --> 00:46:08,068
弹出框中的描述

1077
00:46:08,268 --> 00:46:09,369
让我们来看看这个

1078
00:46:10,404 --> 00:46:12,673
首先我想禁用约束模式和裁剪

1079
00:46:13,640 --> 00:46:15,576
以便我们可以看到内容

1080
00:46:17,110 --> 00:46:18,879
我也将清除控制台

1081
00:46:19,913 --> 00:46:22,549
我一开始向你展示了如何在这款
Mac app处于活动状态时

1082
00:46:22,749 --> 00:46:26,420
进行捕捉
这样我们就可以在弹出窗口打开时

1083
00:46:26,486 --> 00:46:27,754
看到其视图层次结构

1084
00:46:28,188 --> 00:46:29,223
然而我们没有看到它

1085
00:46:29,423 --> 00:46:32,593
这是因为视图调试器
一次只显示一个窗口

1086
00:46:33,493 --> 00:46:35,562
我们来看看如何查看其他窗口

1087
00:46:36,363 --> 00:46:39,132
当我在视图层次结构中向上滚动

1088
00:46:39,333 --> 00:46:42,736
并最终找到当前窗口时

1089
00:46:43,003 --> 00:46:45,005
我们可以看到它在窗口控制器下面

1090
00:46:45,138 --> 00:46:48,108
如果我在这里折叠这个根项目

1091
00:46:48,342 --> 00:46:50,344
我们可以看到实际上有另一个根项目

1092
00:46:50,410 --> 00:46:52,079
这正是我们正在寻找的

1093
00:46:52,646 --> 00:46:53,647
我们的弹出窗口

1094
00:46:54,281 --> 00:46:55,949
所以如果你的app有多个窗口

1095
00:46:56,016 --> 00:46:58,018
macOS和iOS也是如此

1096
00:46:58,352 --> 00:47:00,053
它们会在左侧的导航栏中

1097
00:46:58,352 --> 00:47:00,053
它们会在左侧的导航栏中

1098
00:47:00,120 --> 00:47:02,222
显示为多个根级别的对象

1099
00:47:02,756 --> 00:47:05,859
所以如果你认为你的app
包含多个窗口

1100
00:47:06,059 --> 00:47:07,427
那么就看看那里

1101
00:47:07,494 --> 00:47:09,296
它们会被视图调试器所捕获

1102
00:47:10,397 --> 00:47:11,932
我们可以在3D模式下看看它

1103
00:47:12,099 --> 00:47:14,067
我们可以看到这个大视图

1104
00:47:14,468 --> 00:47:17,938
阻挡了我们对标签的点击

1105
00:47:18,038 --> 00:47:20,440
我想看看这些标签以检查它们

1106
00:47:21,008 --> 00:47:23,477
让点击穿过视图调试器中的视图
有一个技巧

1107
00:47:23,544 --> 00:47:25,012
你只需按住Command键

1108
00:47:25,612 --> 00:47:28,749
现在我可以穿过前面这个视图
并点击选中这个蓝色标签

1109
00:47:29,449 --> 00:47:31,952
我们来看看这个标签的文字颜色

1110
00:47:32,252 --> 00:47:34,621
我想先看看在暗色中
看起来很棒的那些标签

1111
00:47:34,688 --> 00:47:36,723
以便我们可以为底部的问题标签

1112
00:47:36,790 --> 00:47:38,592
找出解决方案

1113
00:47:39,993 --> 00:47:41,228
我们来看看文字的颜色

1114
00:47:41,295 --> 00:47:43,030
我们可以看到这是一种RGB颜色

1115
00:47:43,764 --> 00:47:46,800
效果为这种蓝色
我们也可以看到信息栏向我们提供了

1116
00:47:47,134 --> 00:47:48,168
这种颜色的名称

1117
00:47:48,235 --> 00:47:49,803
这表明这种颜色

1118
00:47:50,170 --> 00:47:52,472
来自我们项目中的素材目录

1119
00:47:52,906 --> 00:47:55,843
在Xcode 10中
你可以提供你定义的

1120
00:47:56,243 --> 00:47:57,611
单个颜色的多种颜色变体

1121
00:47:57,744 --> 00:48:00,280
例如 你可以提供一种用于浅色
另一种用于暗色

1122
00:47:57,744 --> 00:48:00,280
例如 你可以提供一种用于浅色
另一种用于暗色

1123
00:48:00,747 --> 00:48:04,551
并且使用哪种颜色变体

1124
00:48:04,618 --> 00:48:05,819
取决于视图的外观

1125
00:48:05,986 --> 00:48:06,820
你也可以

1126
00:48:07,187 --> 00:48:08,989
在信息栏中得到这些信息

1127
00:48:09,389 --> 00:48:11,225
向下滚动信息栏

1128
00:48:11,291 --> 00:48:12,259
到视图部分

1129
00:48:12,426 --> 00:48:13,794
你可以看到有Appearance

1130
00:48:13,861 --> 00:48:14,962
和Effective外观选项

1131
00:48:15,395 --> 00:48:18,298
现在Appearance选项
没有在这个视图上明确设置

1132
00:48:18,365 --> 00:48:19,900
这是一种非常常见的情况

1133
00:48:19,967 --> 00:48:21,635
因为大多数视图继承了

1134
00:48:22,035 --> 00:48:24,771
其任意一个父视图的外观

1135
00:48:24,838 --> 00:48:26,340
比如窗口或app

1136
00:48:27,107 --> 00:48:29,610
但是你可以在这里看到
所继承的有效外观

1137
00:48:29,676 --> 00:48:30,944
那就是VibrantDark

1138
00:48:31,411 --> 00:48:32,880
这将决定你在素材目录中

1139
00:48:32,946 --> 00:48:35,415
定义的哪种颜色会被使用

1140
00:48:36,683 --> 00:48:39,386
好的 事实上在信息栏的此处

1141
00:48:39,887 --> 00:48:41,622
我想指出
Description属性

1142
00:48:41,688 --> 00:48:43,757
这是该对象的调试描述

1143
00:48:44,157 --> 00:48:46,727
Chris先前向你展示了
如何为你的对象提供

1144
00:48:46,793 --> 00:48:47,661
自定义调试描述

1145
00:48:47,861 --> 00:48:49,363
所以你不仅受益于

1146
00:48:49,696 --> 00:48:52,132
当你在对象上使用po时

1147
00:48:52,199 --> 00:48:54,368
你的控制台会显示清晰的调试描述

1148
00:48:54,434 --> 00:48:56,336
你也可以从视图调试器中获益

1149
00:48:56,403 --> 00:48:58,105
因为它在信息栏中也会显示

1150
00:48:59,506 --> 00:49:01,542
好的 让我们回到文本颜色

1151
00:48:59,506 --> 00:49:01,542
好的 让我们回到文本颜色

1152
00:49:01,909 --> 00:49:04,778
我想选择第二个标签
因为它在暗色中看起来也还不错

1153
00:49:05,412 --> 00:49:07,414
这次我们仍可以看到
一个带有名称的颜色

1154
00:49:07,481 --> 00:49:09,950
它是labelColor
但它以System为前缀

1155
00:49:10,217 --> 00:49:12,753
这表明它不是
来自我们自己的素材目录

1156
00:49:12,886 --> 00:49:13,787
而是来自系统

1157
00:49:14,021 --> 00:49:15,155
当然 系统颜色

1158
00:49:15,222 --> 00:49:17,324
也会自动适应外观变化

1159
00:49:18,292 --> 00:49:20,928
现在看看这个有问题的标签

1160
00:49:21,461 --> 00:49:23,630
我们可以看到它是非常深的灰色

1161
00:49:24,131 --> 00:49:25,098
并且没有名字

1162
00:49:25,165 --> 00:49:27,267
这意味着它是一种自定义颜色

1163
00:49:27,334 --> 00:49:30,037
它不会适应外观变化

1164
00:49:30,971 --> 00:49:33,841
所以我们想要做的是改变它的颜色

1165
00:49:33,907 --> 00:49:36,343
将其文本颜色设置为系统颜色

1166
00:49:37,911 --> 00:49:40,314
所以选中这个对象后
我按下Command-C键

1167
00:49:41,181 --> 00:49:45,352
键入e命令 粘贴类型转换后的指针
并设置setTextColor

1168
00:49:47,654 --> 00:49:49,723
为NSColortextColor

1169
00:49:51,358 --> 00:49:53,327
我必须再次刷新才能看到效果

1170
00:49:53,994 --> 00:49:55,863
我们可以看到弹出框现在更新了

1171
00:49:55,929 --> 00:49:57,531
字体很好看并且可读性强

1172
00:49:58,832 --> 00:50:01,902
现在 我不打算在我的故事本文件中
应用此修复

1173
00:49:58,832 --> 00:50:01,902
现在 我不打算在我的故事本文件中
应用此修复

1174
00:50:02,569 --> 00:50:05,272
但我想指出的一点是
你这么做很重要

1175
00:50:05,506 --> 00:50:08,942
即当你对用户界面进行更改时
你需要验证你的app

1176
00:50:09,243 --> 00:50:11,478
在所有外观中都仍然很好看

1177
00:50:11,712 --> 00:50:13,981
因为现在存在多种系统外观

1178
00:50:14,047 --> 00:50:15,449
我会告诉你如何做到这一点

1179
00:50:15,616 --> 00:50:16,550
我将继续运行

1180
00:50:18,418 --> 00:50:20,888
我并不需要将我的整个系统外观
切换为浅色

1181
00:50:21,021 --> 00:50:24,424
以查看标签在浅色背景下
是否仍然看起来不错

1182
00:50:24,958 --> 00:50:26,426
Xcode 10
为你提供了一种方法

1183
00:50:26,760 --> 00:50:29,229
来仅仅改变目标app的外观

1184
00:50:29,463 --> 00:50:31,565
你可以在调试栏中使用这个按钮

1185
00:50:31,999 --> 00:50:32,933
我可以在这里选择Light

1186
00:50:33,834 --> 00:50:37,037
你可以看到app
现在以浅色外观呈现

1187
00:50:37,504 --> 00:50:40,440
我可以调出弹出框
从而验证

1188
00:50:41,108 --> 00:50:42,309
其文本清晰可读

1189
00:50:42,609 --> 00:50:45,312
这证实我们的确
解决了我们的问题

1190
00:50:45,746 --> 00:50:47,481
由于以不同的外观查看你的app

1191
00:50:47,548 --> 00:50:49,983
是一个非常普遍的行为

1192
00:50:50,050 --> 00:50:52,753
我们实际上在触摸栏中提供了该选项

1193
00:50:53,053 --> 00:50:54,188
我马上向你演示一下

1194
00:50:54,454 --> 00:50:56,223
我将再次调出触摸栏模拟器

1195
00:50:56,523 --> 00:50:58,091
并打开弹出框

1196
00:50:59,126 --> 00:51:00,694
我可以选择这个选项

1197
00:50:59,126 --> 00:51:00,694
我可以选择这个选项

1198
00:51:01,728 --> 00:51:03,463
你现在可以在触控栏中

1199
00:51:03,530 --> 00:51:04,464
看到所有的覆盖选项

1200
00:51:04,698 --> 00:51:06,667
所以即使你的app处于全屏模式

1201
00:51:06,733 --> 00:51:08,001
你也可以访问它们

1202
00:51:08,735 --> 00:51:10,270
让我切换到
High Contrast Light模式

1203
00:51:10,504 --> 00:51:14,341
它可以实现高对比度的无障碍功能

1204
00:51:14,842 --> 00:51:17,277
同时覆盖外观为浅色

1205
00:51:17,778 --> 00:51:21,615
这样你可以确保你的app
在该配置中也看起来不错

1206
00:51:22,282 --> 00:51:24,818
当然我也可以回到系统外观

1207
00:51:25,719 --> 00:51:27,721
我们确认了我们的问题已经解决

1208
00:51:28,822 --> 00:51:30,924
现在我可以在漏洞列表中勾掉它

1209
00:51:31,491 --> 00:51:33,827
就这样
我们完成了我们的演示

1210
00:51:33,894 --> 00:51:35,429
我会回到幻灯片

1211
00:51:43,737 --> 00:51:45,339
让我们回顾一下刚刚看到的内容

1212
00:51:46,240 --> 00:51:48,775
我向你展示了如何使用
Reveal in Debug Navigator选项

1213
00:51:48,842 --> 00:51:50,210
在左侧的层次结构中

1214
00:51:50,611 --> 00:51:52,813
定位你当前选中的对象

1215
00:51:53,380 --> 00:51:55,549
我向你展示了如何显示裁剪内容

1216
00:51:56,650 --> 00:51:58,886
并且我们使用了自动布局调试功能

1217
00:51:58,952 --> 00:52:00,821
来定位我们的约束问题

1218
00:51:58,952 --> 00:52:00,821
来定位我们的约束问题

1219
00:52:01,321 --> 00:52:03,724
我向你展示了如何使用对象指针

1220
00:52:03,790 --> 00:52:07,127
要使用它你只需复制选定对象

1221
00:52:07,194 --> 00:52:08,362
并在LLDB中使用

1222
00:52:08,862 --> 00:52:10,564
我们看了一下构建过程回溯

1223
00:52:10,764 --> 00:52:12,766
如果你在Scheme Options中
启用了

1224
00:52:12,833 --> 00:52:14,368
Malloc Stack日志
就可以使用它

1225
00:52:15,202 --> 00:52:17,271
来直接跳转到代码

1226
00:52:17,671 --> 00:52:19,239
并应用约束所需的更改

1227
00:52:19,840 --> 00:52:21,742
我们看了一下调试描述

1228
00:52:21,875 --> 00:52:24,578
它在视图调试器的信息栏中
用起来很方便

1229
00:52:25,412 --> 00:52:27,848
我们使用了点击量功能

1230
00:52:27,981 --> 00:52:29,683
来选中位于一个视图后面的视图

1231
00:52:31,018 --> 00:52:32,586
关于调试暗色模式

1232
00:52:32,653 --> 00:52:36,356
我们看到你可以通过直接使用
Xcode的调试栏或触摸栏

1233
00:52:36,557 --> 00:52:38,792
轻松更改目标app的外观

1234
00:52:39,660 --> 00:52:42,196
我向你展示了如何捕捉
处于活动状态的Mac app

1235
00:52:42,396 --> 00:52:44,464
我们也看了一下命名颜色信息

1236
00:52:44,531 --> 00:52:45,599
及其NSAppearance信息

1237
00:52:45,666 --> 00:52:48,068
它们在Xcode的视图调试器的
信息栏中可见

1238
00:52:49,303 --> 00:52:51,572
若你想了解更多
关于在你的Mac app中

1239
00:52:51,738 --> 00:52:53,407
使用暗色模式的信息

1240
00:52:53,807 --> 00:52:55,976
请观看这两场演讲的视频

1241
00:52:57,344 --> 00:52:59,179
我们这次的演讲就到此结束了

1242
00:52:59,847 --> 00:53:01,615
若你想了解更多此次演讲的信息

1243
00:52:59,847 --> 00:53:01,615
若你想了解更多此次演讲的信息

1244
00:53:01,682 --> 00:53:04,785
包括Chris先前向你展示的
nudge脚本

1245
00:53:05,252 --> 00:53:07,254
它们会被发布在演讲网站上

1246
00:53:07,521 --> 00:53:10,090
如果你对本次演讲的任何内容
或一般性调试问题

1247
00:53:10,591 --> 00:53:11,792
有任何疑问

1248
00:53:11,992 --> 00:53:14,728
明天上午9点将有一个
分析和调试实验室

1249
00:53:14,962 --> 00:53:15,829
Chris和我会在那里

1250
00:53:15,896 --> 00:53:17,898
我们很乐意回答
你可能遇到的任何问题

1251
00:53:18,165 --> 00:53:20,467
另外如果你对内存调试感兴趣

1252
00:53:20,634 --> 00:53:22,603
还有一个“iOS内存深潜”演讲

1253
00:53:22,836 --> 00:53:23,770
它也在明天

1254
00:53:24,905 --> 00:53:27,708
最后 我希望你在啤酒狂欢节中
度过美妙的时光

1255
00:53:27,774 --> 00:53:29,243
并享受此次大会的其余部分